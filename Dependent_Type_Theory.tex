
\documentclass[12pt, a4paper, openany, twoside]{book}
\usepackage[left=1in,right=1in,bottom=0.5in,top=0.8in]{geometry}
\usepackage{amsfonts}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{epstopdf}
\usepackage[pdfpagelabels,hyperindex]{hyperref}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{float}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{longtable}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[most]{tcolorbox}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz-cd}
\usepackage{comment}
\usepackage{mathpartir}

\linespread{1.2} 

\hypersetup{
pdftitle={.},
pdfauthor={Hojune Lee},
}

\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\DeclareRobustCommand{\stirling}{\genfrac\{\}{0pt}{}}
\newtheorem{thm}{Theorem}[subsection]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{quest}[thm]{Question}
\newtheorem{ppty}[thm]{Property}
\newtheorem{ppties}[thm]{Properties}
\newtheorem{axiom}[thm]{Axiom}
\newtheorem{claim}[thm]{Claim}
\newtheorem{prob}[thm]{Problem}


\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{defns}[thm]{Definitions}
\newtheorem{con}[thm]{Construction}
\newtheorem{exmp}[thm]{Example}
\newtheorem{exmps}[thm]{Examples}
\newtheorem{notn}[thm]{Notation}
\newtheorem{notns}[thm]{Notations}
\newtheorem{addm}[thm]{Addendum}
\newtheorem{exer}[thm]{Exercise}
\newtheorem{limit}[thm]{Limitation}


\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\newtheorem{rems}[thm]{Remarks}
\newtheorem{warn}[thm]{Warning}
\newtheorem{sch}[thm]{Scholium}
\newenvironment{thmbox}[1][]{\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title={#1}]}{\end{tcolorbox}}


% newcommand bb
    \newcommand{\BA}{{\mathbb {A}}} \newcommand{\BB}{{\mathbb {B}}}
    \newcommand{\BC}{{\mathbb {C}}} \newcommand{\BD}{{\mathbb {D}}}
    \newcommand{\BE}{{\mathbb {E}}} \newcommand{\BF}{{\mathbb {F}}}
    \newcommand{\BG}{{\mathbb {G}}} \newcommand{\BH}{{\mathbb {H}}}
    \newcommand{\BI}{{\mathbb {I}}} \newcommand{\BJ}{{\mathbb {J}}}
    \newcommand{\BK}{{\mathbb {U}}} \newcommand{\BL}{{\mathbb {L}}}
    \newcommand{\BM}{{\mathbb {M}}} \newcommand{\BN}{{\mathbb {N}}}
    \newcommand{\BO}{{\mathbb {O}}} \newcommand{\BP}{{\mathbb {P}}}
    \newcommand{\BQ}{{\mathbb {Q}}} \newcommand{\BR}{{\mathbb {R}}}
    \newcommand{\BS}{{\mathbb {S}}} \newcommand{\BT}{{\mathbb {T}}}
    \newcommand{\BU}{{\mathbb {U}}} \newcommand{\BV}{{\mathbb {V}}}
    \newcommand{\BW}{{\mathbb {W}}} \newcommand{\BX}{{\mathbb {X}}}
    \newcommand{\BY}{{\mathbb {Y}}} \newcommand{\BZ}{{\mathbb {Z}}}

% newcommand  scr
    \newcommand{\sA}{{\mathscr {A}}} \newcommand{\sB}{{\mathscr {B}}}
    \newcommand{\sC}{{\mathscr {C}}} \newcommand{\sD}{{\mathscr {D}}}
    \newcommand{\sE}{{\mathscr {E}}} \newcommand{\sF}{{\mathscr {F}}}
    \newcommand{\sG}{{\mathscr {G}}} \newcommand{\sH}{{\mathscr {H}}}
    \newcommand{\sI}{{\mathscr {I}}} \newcommand{\sJ}{{\mathscr {J}}}
    \newcommand{\sK}{{\mathscr {K}}} \newcommand{\sL}{{\mathscr {L}}}
    \newcommand{\sN}{{\mathscr {N}}} \newcommand{\sM}{{\mathscr {M}}}
    \newcommand{\sO}{{\mathscr {O}}} \newcommand{\sP}{{\mathscr {P}}}
    \newcommand{\sQ}{{\mathscr {Q}}} \newcommand{\sR}{{\mathscr {R}}}
    \newcommand{\sS}{{\mathscr {S}}} \newcommand{\sT}{{\mathscr {T}}}
    \newcommand{\sU}{{\mathscr {U}}} \newcommand{\sV}{{\mathscr {V}}}
    \newcommand{\sW}{{\mathscr {W}}} \newcommand{\sX}{{\mathscr {X}}}
    \newcommand{\sY}{{\mathscr {Y}}} \newcommand{\sZ}{{\mathscr {Z}}}


% newcommand cal
    \newcommand{\CA}{{\mathcal {A}}} \newcommand{\CB}{{\mathcal {B}}}
    \newcommand{\CC}{{\mathcal {C}}} \newcommand{\CD}{{\mathcal {D}}}
    \newcommand{\CE}{{\mathcal {E}}} \newcommand{\CF}{{\mathcal {F}}}
    \newcommand{\CG}{{\mathcal {G}}} \newcommand{\CH}{{\mathcal {H}}}
    \newcommand{\CI}{{\mathcal {I}}} \newcommand{\CJ}{{\mathcal {J}}}
    \newcommand{\CK}{{\mathcal {K}}} \newcommand{\CL}{{\mathcal {L}}}
    \newcommand{\CM}{{\mathcal {M}}} \newcommand{\CN}{{\mathcal {N}}}
    \newcommand{\CO}{{\mathcal {O}}} \newcommand{\CP}{{\mathcal {P}}}
    \newcommand{\CQ}{{\mathcal {Q}}} \newcommand{\CR}{{\mathcal {R}}}
    \newcommand{\CS}{{\mathcal {S}}} \newcommand{\CT}{{\mathcal {T}}}
    \newcommand{\CU}{{\mathcal {U}}} \newcommand{\CV}{{\mathcal {V}}}
    \newcommand{\CW}{{\mathcal {W}}} \newcommand{\CX}{{\mathcal {X}}}
    \newcommand{\CY}{{\mathcal {Y}}} \newcommand{\CZ}{{\mathcal {Z}}}

    % newcommand frak
     \newcommand{\fa}{{\mathfrak{a}}}  \newcommand{\fb}{{\mathfrak{b}}}
     \newcommand{\fc}{{\mathfrak{c}}}  \newcommand{\fd}{{\mathfrak{d}}}
     \newcommand{\fe}{{\mathfrak{e}}}  \newcommand{\ff}{{\mathfrak{f}}}
     \newcommand{\fg}{{\mathfrak{g}}}  \newcommand{\fh}{{\mathfrak{h}}}
     \newcommand{\fii}{{\mathfrak{i}}}  \newcommand{\fj}{{\mathfrak{j}}}
     \newcommand{\fk}{{\mathfrak{m}}}  \newcommand{\fl}{{\mathfrak{l}}}
     \newcommand{\fm}{{\mathfrak{m}}}  \newcommand{\fn}{{\mathfrak{n}}}
     \newcommand{\fo}{{\mathfrak{o}}}  \newcommand{\fp}{{\mathfrak{p}}}
     \newcommand{\fq}{{\mathfrak{q}}}  \newcommand{\fr}{{\mathfrak{r}}}
     \newcommand{\fs}{{\mathfrak{s}}}  \newcommand{\ft}{{\mathfrak{t}}}
     \newcommand{\fu}{{\mathfrak{u}}}  \newcommand{\fv}{{\mathfrak{v}}}
     \newcommand{\fw}{{\mathfrak{w}}}  \newcommand{\fx}{{\mathfrak{x}}}
     \newcommand{\fy}{{\mathfrak{y}}}  \newcommand{\fz}{{\mathfrak{z}}}

    \newcommand{\fA}{{\mathfrak{A}}}  \newcommand{\fB}{{\mathfrak{B}}}
     \newcommand{\fC}{{\mathfrak{C}}}  \newcommand{\fD}{{\mathfrak{D}}}
     \newcommand{\fE}{{\mathfrak{E}}}  \newcommand{\fF}{{\mathfrak{F}}}
     \newcommand{\fG}{{\mathfrak{G}}}  \newcommand{\fH}{{\mathfrak{H}}}
     \newcommand{\fI}{{\mathfrak{I}}}  \newcommand{\fJ}{{\mathfrak{J}}}
     \newcommand{\fK}{{\mathfrak{K}}}  \newcommand{\fL}{{\mathfrak{L}}}
     \newcommand{\fM}{{\mathfrak{M}}}  \newcommand{\fN}{{\mathfrak{N}}}
     \newcommand{\fO}{{\mathfrak{O}}}  \newcommand{\fP}{{\mathfrak{P}}}
     \newcommand{\fQ}{{\mathfrak{Q}}}  \newcommand{\fR}{{\mathfrak{R}}}
     \newcommand{\fS}{{\mathfrak{S}}}  \newcommand{\fT}{{\mathfrak{T}}}
     \newcommand{\fU}{{\mathfrak{U}}}  \newcommand{\fV}{{\mathfrak{V}}}
     \newcommand{\fW}{{\mathfrak{W}}}  \newcommand{\fX}{{\mathfrak{X}}}
     \newcommand{\fY}{{\mathfrak{Y}}}  \newcommand{\fZ}{{\mathfrak{Z}}}



 % newcommand :rm
     \newcommand{\RA}{{\mathrm {A}}} \newcommand{\RB}{{\mathrm {B}}}
    \newcommand{\RC}{{\mathrm {C}}} \newcommand{\RD}{{\mathrm {D}}}
    \newcommand{\RE}{{\mathrm {E}}} \newcommand{\RF}{{\mathrm {F}}}
    \newcommand{\RG}{{\mathrm {G}}} \newcommand{\RH}{{\mathrm {H}}}
    \newcommand{\RI}{{\mathrm {I}}} \newcommand{\RJ}{{\mathrm {J}}}
    \newcommand{\RK}{{\mathrm {K}}} \newcommand{\RL}{{\mathrm {L}}}
    \newcommand{\RM}{{\mathrm {M}}} \newcommand{\RN}{{\mathrm {N}}}
    \newcommand{\RO}{{\mathrm {O}}} \newcommand{\RP}{{\mathrm {P}}}
    \newcommand{\RQ}{{\mathrm {Q}}} \newcommand{\RR}{{\mathrm {R}}}
    \newcommand{\RS}{{\mathrm {S}}} \newcommand{\RT}{{\mathrm {T}}}
    \newcommand{\RU}{{\mathrm {U}}} \newcommand{\RV}{{\mathrm {V}}}
    \newcommand{\RW}{{\mathrm {W}}} \newcommand{\RX}{{\mathrm {X}}}
    \newcommand{\RY}{{\mathrm {Y}}} \newcommand{\RZ}{{\mathrm {Z}}}

    \newcommand{\Ad}{{\mathrm{Ad}}} \newcommand{\Aut}{{\mathrm{Aut}}}
    \newcommand{\Br}{{\mathrm{Br}}} \newcommand{\Ch}{{\mathrm{Ch}}}
    \newcommand{\cod}{{\mathrm{cod}}} \newcommand{\cont}{{\mathrm{cont}}}
    \newcommand{\cl}{{\mathrm{cl}}}   \newcommand{\Cl}{{\mathrm{Cl}}}
    \newcommand{\disc}{{\mathrm{disc}}}\newcommand{\Eis}{{\mathrm{Eis}}}
    \newcommand{\Div}{{\mathrm{Div}}} \renewcommand{\div}{{\mathrm{div}}}
    \newcommand{\End}{{\mathrm{End}}} \newcommand{\Frob}{{\mathrm{Frob}}}
    \newcommand{\Gal}{{\mathrm{Gal}}} \newcommand{\GL}{{\mathrm{GL}}}
    \newcommand{\Hom}{{\mathrm{Hom}}} \renewcommand{\Im}{{\mathrm{Im}}}
    \newcommand{\Ind}{{\mathrm{Ind}}} \newcommand{\ind}{{\mathrm{ind}}}
    \newcommand{\inv}{{\mathrm{inv}}}
    \newcommand{\Isom}{{\mathrm{Isom}}} \newcommand{\Jac}{{\mathrm{Jac}}}
    \newcommand{\ad}{{\mathrm{ad}}}  \newcommand{\Tr}{{\mathrm{Tr}}}
    \newcommand{\Ker}{{\mathrm{Ker}}} \newcommand{\Ros}{{\mathrm{Ros}}}
    \newcommand{\Lie}{{\mathrm{Lie}}} \newcommand{\Hol}{{\mathrm{Hol}}}

    \newcommand{\cyc}{{\mathrm{cyc}}}\newcommand{\id}{{\mathrm{id}}}
    \newcommand{\new}{{\mathrm{new}}} \newcommand{\NS}{{\mathrm{NS}}}
    \newcommand{\ord}{{\mathrm{ord}}} \newcommand{\rank}{{\mathrm{rank}}}
    \newcommand{\PGL}{{\mathrm{PGL}}} \newcommand{\Pic}{\mathrm{Pic}}
    \newcommand{\cond}{\mathrm{cond}} \newcommand{\Is}{{\mathrm{Is}}}
    \renewcommand{\Re}{{\mathrm{Re}}} \newcommand{\reg}{{\mathrm{reg}}}
    \newcommand{\Res}{{\mathrm{Res}}} \newcommand{\Sel}{{\mathrm{Sel}}}
    \newcommand{\RTr}{{\mathrm{Tr}}} \newcommand{\alg}{{\mathrm{alg}}}
    \newcommand{\PSL}{{\mathrm{PSL}}}

\newcommand{\coker}{{\mathrm{coker}}}
\newcommand{\val}{{\mathrm{val}}} \newcommand{\sign}{{\mathrm{sign}}}
\newcommand{\mult}{{\mathrm{mult}}} \newcommand{\Vol}{{\mathrm{Vol}}}
\newcommand{\Meas}{{\mathrm{Meas}}}\renewcommand{\mod}{\ \mathrm{mod}\ }
\newcommand{\Ann}{\mathrm{Ann}}
\newcommand{\Tor}{\mathrm{Tor}}
\newcommand{\Supp}{\mathrm{Supp}}\newcommand{\supp}{\mathrm{supp}}
\newcommand{\Max}{\mathrm{Max}}
\newcommand{\Coker}{\mathrm{Coker}}
\newcommand{\Stab}{\mathrm{Stab}}
\newcommand{\Irr}{\mathrm{Irr}}\newcommand{\Inf}{\mathrm{Inf}}\newcommand{\Sup}{\mathrm{Sup}}
\newcommand{\rk}{\mathrm{rk}}\newcommand{\Fil}{\mathrm{Fil}}
\newcommand{\Sim}{{\mathrm{Sim}}} \newcommand{\SL}{{\mathrm{SL}}}
\newcommand{\Spec}{{\mathrm{Spec}}} \newcommand{\SO}{{\mathrm{SO}}}
\newcommand{\SU}{{\mathrm{SU}}} \newcommand{\Sym}{{\mathrm{Sym}}}
\newcommand{\sgn}{{\mathrm{sgn}}} \newcommand{\tr}{{\mathrm{tr}}}
\newcommand{\tor}{{\mathrm{tor}}}  \newcommand{\ur}{{\mathrm{ur}}}
\newcommand{\vol}{{\mathrm{vol}}}  \newcommand{\ab}{{\mathrm{ab}}}
\newcommand{\Sh}{{\mathrm{Sh}}} \newcommand{\Ell}{{\mathrm{Ell}}}
\newcommand{\Char}{{\mathrm{Char}}}\newcommand{\Tate}{{\mathrm{Tate}}}
\newcommand{\corank}{{\mathrm{corank}}} \newcommand{\Cond}{{\mathrm{Cond}}}
\newcommand{\Inn}{{\mathrm{Inn}}} \newcommand{\Spf}{{\mathrm{Spf}}}
\newcommand{\Mat}{{\mathrm{Mat}}}


    \font\cyr=wncyr10  \newcommand{\Sha}{\hbox{\cyr X}}
    \newcommand{\wt}{\widetilde} \newcommand{\wh}{\widehat} \newcommand{\ck}{\check}
    \newcommand{\pp}{\frac{\partial\bar\partial}{\pi i}}
    \newcommand{\pair}[1]{\langle {#1} \rangle}
    \newcommand{\wpair}[1]{\left\{{#1}\right\}}
    \newcommand{\intn}[1]{\left( {#1} \right)}
    \newcommand{\norm}[1]{\|{#1}\|}
    \newcommand{\sfrac}[2]{\left( \frac {#1}{#2}\right)}
    \newcommand{\ds}{\displaystyle}
    \newcommand{\ov}{\overline}
    \newcommand{\Gros}{Gr\"{o}ssencharaktere}
    \newcommand{\incl}{\hookrightarrow}
    \newcommand{\lra}{\longrightarrow}
     \newcommand{\ra}{\rightarrow}
    \newcommand{\imp}{\Longrightarrow}
    \newcommand{\lto}{\longmapsto}
    \newcommand{\bs}{\backslash}
    \newcommand{\nequiv}{\equiv\hspace{-7.8pt}/}
    \theoremstyle{plain}


\definecolor{energy}{RGB}{114,0,172}
\definecolor{freq}{RGB}{45,177,93}
\definecolor{spin}{RGB}{251,0,29}
\definecolor{signal}{RGB}{203,23,206}
\definecolor{circle}{RGB}{217,86,16}
\definecolor{average}{RGB}{203,23,206}
\newcommand{\K}{\operatornamewithlimits{K}}
\colorlet{shadecolor}{gray!20}
\pgfplotsset{compat=1.9}
\def\N{10}
\def\M{4}
\usepgflibrary{fpu}


\def\upint{\mathchoice%
    {\mkern13mu\overline{\vphantom{\intop}\mkern7mu}\mkern-20mu}%
    {\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
    {\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
    {\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
  \int}
\def\lowint{\mkern3mu\underline{\vphantom{\intop}\mkern7mu}\mkern-10mu\int}



\makeatletter
\let\c@equation\c@thm
\raggedbottom
\makeatother
\numberwithin{equation}{section}
%--------Meta Data: Fill in your info------
\author{Hojune Lee, 20210541}

\title{Dependent Type Theory}
\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{9cm}
            
        \Huge
        \textbf{Dependent Type Theory}
    
        \vspace{1cm}
        \large
        Summary note of Angiuli \& Gratzer's Dependent Type Theory.
        \vspace{3cm}
        
        \LARGE
        \textbf{Hojune Lee}
            
        \vspace{8cm}
            
        \normalsize
        \textbf{School of Computing, KAIST}\\  
    \end{center}
\end{titlepage}

This is my summary note of KAIST CS520 Graduated PL course of 2025 Fall.
Instructor is Prof. Hongseok Yang, and all the materials are based on 
textbook by Angiuli \& Gratzer's Dependent Type Theory. 

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}

\newpage 

\chapter{Context and Substitutions}

\section{Intuitions}

In simple type theory, every thing was quite clear. This is because that, if we once fix the rules for types in simple type theory, 
then all possible types are determined immediately by inductive way. We can informally think this as \lq propositional logic'-like type construction. 
However, many things are different in dependent type system. Let's think dependent type system as \lq first order logic'-like type construction. 
Imagine the formulas in first order logic as types in dependent type theory. 
I hope that this is proper intuitive thinking for the main differences between two type systems. \\

Once we imagine FOL formula-style type, it means that each type can contain variables and constants as it's representation. 
It means that for each variables which are appeared in type representation, we must know what are the types of each variables.
That is Context's role. \\

Now, we need to construct the intuition for contexts and substitutions. Contexts are \lq wolrds' of terms and types. 
And substitutions are \lq traffic way' between each worlds( contexts ). Then naturally, following questions are arising. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Questions]
    \begin{enumerate}
        \item Is this world ( Context ) well-formed ?
        \item In this world ( Context ) $\Gamma$, what terms of type $A$ are well-formed ? 
        \item In this world ( Context ) $\Gamma$, what types are well-formed ? 
        \item Between 2 worlds ( Context ) $\Delta$ and $\Gamma$, is traffic way ( substitution ) $\gamma$ well-formed ?
        \item In this world ( Context ), which terms/types/substitutions are equivalent? 
    \end{enumerate}
\end{tcolorbox}

Actually, this is all about \lq judgement rules' referred in Notation 2.3.1. of textbook. 
Formally, we can write format for above judgements. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Formal Representations for Judgements]
    \begin{enumerate}
        \item $\vdash \Gamma \text{ cx}$
        \item $\Gamma \vdash a : A$
        \item $\Gamma \vdash A \text{ type}$
        \item $\Delta \vdash \gamma : \Gamma$
        \item $\Gamma \vdash a = a' : A, \quad \Gamma \vdash A = A' \text{ type}, \quad \Delta \vdash \gamma = \gamma' : \Gamma$ 
    \end{enumerate}
\end{tcolorbox}

In this chapter, we'll discuss the rules for above judgements. 
Now, it's time to define explicit judgement rules that we referred. 
\newpage
\section{Contexts Judgements}
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.2.1.]\label{cx judgement}
    \begin{mathpar}
    \inferrule
    { }
    {\vdash \mathbf{1} \text{ cx}}
    \and   
    \inferrule
    {\vdash \Gamma \text{ cx} \quad \Gamma \vdash A \text{ type}}
    {\vdash \Gamma.A \text{ cx}}
    \end{mathpar}
\end{tcolorbox}
Here, $\mathbf{1}$ is empty context and each context is just list of types. (No variable names) It means that 
we use De Bruijn index, i.e. in each context, index automatically determines the variable in context. 

\section{Substitution Judgements}\label{subst judgement} \quad \\

However, before that the most 
important one is understanding direction of traffic way (from now on, substitution). 

\begin{tcolorbox}[colback=yellow!10!white,colframe=blue!75!black,title=Definition 1.3.1.]\label{1.3.1}
    If $\Delta \vdash \gamma : \Gamma$, then $\gamma$ is substitution from $\Delta$ to $\Gamma$. i.e. 
    \[\gamma : \Delta \rightarrow \Gamma\]
    However, it's role is send types and terms of $\Gamma$ into $\Delta$. (Note : Direction is important)
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=1.3.  Intuitions for direction of substitutions]\label{intuition}
    To understand why here use this notation, see following example. Imagine that contexts are \lq sets' 
    and substitutions are function between them. There are 2 sets $\Delta, \Gamma$ and mapping $\gamma : \Delta \rightarrow \Gamma$. 
    Suppose that there is a function $g : \Gamma \rightarrow \mathbb{R}$, which is defined on set $\Gamma$. How can we 
    \lq use' this function in $\Delta$ set? One way is that, 
    \[g : \Gamma \rightarrow \mathbb{R} \implies g \circ \gamma : \Delta \rightarrow \mathbb{R}\]
    Then we can \lq use' the function $g$ in domain $\Delta$. This exactly corresponds in our notation. 
    For $\Delta \vdash \gamma : \Gamma$, when we define $\gamma : \Delta \rightarrow \Gamma$, 
    \[\Gamma \vdash A \text{ type} \implies \Delta \vdash A[\gamma] \text{ type}\]
    Since $A$ is type in $\Gamma$ and the direction of substitution is $\gamma : \Delta \rightarrow \Gamma$, we say that 
    $A[\gamma]$ is pull-backed type of $A$ through $\gamma : \Delta \rightarrow \Gamma$. 
\end{tcolorbox}

First, as above we can easily define the application rule of substitution. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.2.]
    \begin{mathpar}
    \inferrule
    {\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type}}
    {\Delta \vdash A[\gamma] \text{ type}}
    \and   
    \inferrule
    {\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a : A}
    {\Delta \vdash a[\gamma] : A[\gamma]}
    \end{mathpar}
\end{tcolorbox}
These rules give us that we can immigrate(pull-back) terms and types of $\Gamma$ into $\Delta$. 
And now, in our setting each contexts are different \lq worlds'. So we need to introduce explicit \textbf{weakening rule}, which intuitively means that 
we can bring well-formed types and terms into $\Gamma$ into $\Gamma.A$, expanded context. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.3.]
    \begin{mathpar}
    \inferrule
    {\Gamma \vdash A \text{ type}}
    {\Gamma.A \vdash \mathbf{p} : \Gamma}
    \end{mathpar}
\end{tcolorbox}
In diagram, 
\[
\begin{tikzcd}
{\Gamma.A} \arrow[r, "p"] & {\Gamma} \\
\end{tikzcd}
\]
Means that, we can pull-back types $B$ and terms $t$ in world $\Gamma$ into $\Gamma.A$ by write $B[\mathbf{p}], t[\mathbf{p}]$
Moreover, we can introduce following rules. (Actually, following rules need because our context-substitution system become a category.) 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.4.]
    \begin{mathpar}
    \inferrule
    {\vdash \Gamma \text{ cx}}
    {\Gamma \vdash \mathbf{id} : \Gamma}
    \and   
    \inferrule
    {\Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0}
    {\Gamma_2 \vdash \gamma_0 \circ \gamma_1 : \Gamma_0}
    \end{mathpar}
\end{tcolorbox}
Second one can be conflict when we see first. However, let's draw the diagram. 
\[
\begin{tikzcd}
{\Gamma_2} \arrow[r, "\gamma_1"] \arrow[d, "\gamma_0 \circ \gamma_1"'] & {\Gamma_1} \arrow[ld, "\gamma_0"] &\\
{\Gamma_0} 
\end{tikzcd}\]
Then, above representation is very clear. It become same notation in our function calculus. Similarly, 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.5.]
    \begin{mathpar}
    \inferrule
    {\Delta \vdash \gamma : \Gamma}
    {\Delta \vdash \gamma \circ \mathbf{id} = \mathbf{id} \circ \gamma = \gamma : \Gamma}
    \and   
    \inferrule
    {\Gamma_3 \vdash \gamma_2 : \Gamma_2 \quad \Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0}
    {\Gamma_3 \vdash (\gamma_0 \circ \gamma_1) \circ \gamma_2 = \gamma_0 \circ (\gamma_1 \circ \gamma_2) : \Gamma_0}
    \end{mathpar}
\end{tcolorbox}
This two rules are also very clear when we see the diagram. 
\[
\begin{tikzcd}
{\Delta} \arrow[loop left, "id"] \arrow[r, "\gamma"] & {\Gamma} \arrow[loop right, "id"]
\end{tikzcd}
\]
\\
\[
\begin{tikzcd}[row sep = large, column sep = huge]
    {\Gamma_3} \arrow[r, "\gamma_2"]  \arrow[d, "(\gamma_0 \circ \gamma_1) \circ \gamma_2"'] & {\Gamma_2}\arrow[ld, "\gamma_0 \circ \gamma_1"] \arrow[d, "\gamma_1"] \\
    {\Gamma_0} & {\Gamma_1} \arrow[l, "\gamma_0"] 
\end{tikzcd}
\quad
\iff
\quad
\begin{tikzcd}[row sep = large, column sep = huge]
{\Gamma_3} \arrow[r, "\gamma_2"] \arrow[rd, "\gamma_1 \circ \gamma_2"] \arrow[d, "\gamma_0 \circ (\gamma_1 \circ \gamma_2)"'] & {\Gamma_2} \arrow[d, "\gamma_1"] \\
{\Gamma_0} & {\Gamma_1} \arrow[l, "\gamma_0"] 
\end{tikzcd}
\]
\\
Then we can imagine following equivalent rules clearly. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.6.]
\begin{mathpar}
\inferrule
{\Gamma \vdash A \text{ type}}
{\Gamma \vdash A[\mathbf{id}] = A \text{ type}}
\and   
\inferrule
{\Gamma \vdash a : A}
{\Gamma \vdash a[\mathbf{id}] = a : A}
\end{mathpar}
\\
\[
\inferrule
{\Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0 \quad \Gamma_0 \vdash A \text{ type}}
{\Gamma_2 \vdash A[\gamma_0 \circ \gamma_1] = A[\gamma_0][\gamma_1] \text{ type}}
\]
\\
\[
\inferrule
{\Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0 \quad \Gamma_0 \vdash a : A}
{\Gamma_2 \vdash a[\gamma_0 \circ \gamma_1] = a[\gamma_0][\gamma_1] : A[\gamma_0 \circ \gamma_1]}
\]
\end{tcolorbox}
These rules are very intuitable. When we draw diagram, 
\[
\begin{tikzcd}
    \Gamma_2 \arrow[d, "\gamma_0 \circ \gamma_1"'] \arrow[r, "\gamma_1"] & \Gamma_1 \arrow[ld, "\gamma_0"] \\
    \Gamma_0
\end{tikzcd}
\]
For example, look the last rule. $a$ is term in the world $\Gamma_0$. We want to 
bring this term into $\Gamma_2$. Bring means that, we want to use \lq function' $a$ in $\Gamma_2$. i.e. such term in $\Gamma_2$ is 
working same roles with $a$ in $\Gamma_0$. We've studied in box \ref{intuition}, there are 2 ways to bring $a$ from $\Gamma_0$ into $\Gamma_2$. 
\[
\begin{tikzcd}
    \Gamma_2 \arrow[d, "\gamma_0 \circ \gamma_1"', red] \arrow[r, "\gamma_1", blue] & \Gamma_1 \arrow[ld, "\gamma_0", blue] \\
    \Gamma_0
\end{tikzcd}
\]

One is pulling back via red way, and another one is via blue way. $a$ via red way is $a[\gamma_0 \circ \gamma_1]$ in $\Gamma_2$, 
and via blue way is $a[\gamma_0][\gamma_1]$ (Actually, $a[\gamma_0]$ is $a$ in $\Gamma_1$ wolrd. So we take it again into $\Gamma_2$.)
However, how can we use variable in well-formed context $\Gamma$ without own names? What is the meaning of De Bruijn index? Let's see how can we distinguish
variables in each \lq world' $\Gamma$. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.7.]\label{con 1.3.7.}
\[
\inferrule
{\Gamma \vdash A \text{ type}}
{\Gamma.A \vdash \mathbf{q} : A[\mathbf{p}]}
\]
\end{tcolorbox}
We can see context as a stack. $\mathbf{q}$ always means the top element of stack. 
However, stack $\Gamma.A$ contains type $A$ as top, which is type in $\Gamma$ wolrd. So 
the top variable's type in $\Gamma.A$ is $A[\mathbf{p}]$ which we take $A$ from $\Gamma$ into $\Gamma.A$. Similarly, we can 
access the any index of stack by following rule which is deribable from \ref{con 1.3.7.} 
\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Corolary 1.3.8.]
\[
\inferrule
{\Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B_1 \text{ type} \quad \cdots \Gamma.A.B_1.\cdots \vdash B_n \text{ type}}
{\Gamma.A.B_1.\cdots.B_n \vdash \mathbf{q}[\mathbf{p}^n] : A[\mathbf{p}^{n+1}]}
\]
\end{tcolorbox}
Now, it's time to discuss our main theme in this subsection \ref{subst judgement}.
Our ultimate goal is defining \lq valid traffic way from valid world to another valid world'. Let's discuss substitution 
judgement rules very intuitively. First, suppose that we only have rules for context judgements \ref{cx judgement}. 
The obvious thing that we must do first is, construct way from any $\Gamma$ into $\mathbf{1}$. The rules are simple. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.9.]
\begin{mathpar}
\inferrule
{\vdash \Gamma \text{ cx}}
{\Gamma \vdash ! : \mathbf{1}}
\and   
\inferrule
{\Gamma \vdash \delta : \mathbf{1}}
{\Gamma \vdash \delta = ! : \mathbf{1}}
\end{mathpar}
\end{tcolorbox}
\vspace{4mm}
What does it mean? It is 'way' from $\Gamma$ to $\mathbf{1}$. The role of this way is transfer terms and types in $\mathbf{1}$ into $\Gamma$ world. 
What terms and types are well-formed in $\mathbf{1}$? Just closed terms and types (No Variables). It is obviously 
terms and types in $\Gamma$ also. So we define the way is \lq unique' here. With this substitution, 
we can always transfer closed terms(e.g. 1, (1+1)) and closed types from $\mathbf{1}$ to any well-formed context $\Gamma$.  
Let's think this as a base case of our definition of traffic ways. Following construction determines how can we extends substitutions. 
\vspace{4mm}
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.10.]\hypertarget{subst extend}{}
\[\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta \vdash a : A[\gamma]}
{\Delta \vdash \gamma.a : \Gamma.A}\]
\end{tcolorbox}
Let's draw diagram. \\
\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]
\\
Is it clear? It means that, suppose that $\Gamma$ has $n$ variables ($x_1, \cdots, x_n$). Here we denote names for each variables for representation. 
And then, in this context $\Gamma$, $A$ is well-formed type. Then automatically $\Gamma.A$ is defined, where 
it has $n+1$ variables ($x_1, \cdots, x_n, x_{n+1}$). The key understanding is that, when we bring 
terms and types in $\Gamma.A$ world, it can have $x_1, \cdots, x_{n+1}$ as symbol. When we meet $x_{n+1}$, then substitution it by $a$, and when we meet $x_1, \cdots, x_n$, then substitution it by following $\gamma$. 
Then since $a$ is well-formed term in $\Delta$ and it's type is $A[\gamma]$, which do roles of $A$ in $\Delta$ world, so such substitution also works well. This is very powerful intuition. 
Now, with above understanding, let's define more challenging and powerful rules for substitutions. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.11.]\hypertarget{construction 1.3.11}{}

\[
\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta \vdash a : A[\gamma]}
{\Delta \vdash \mathbf{p} \circ (\gamma.a) = \gamma : \Gamma}
\]
\\
\[
\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta \vdash a : A[\gamma]}
{\Delta \vdash \mathbf{q}[\gamma.a] = a : A[\gamma]}
\]
\\
\[
\inferrule
{\Gamma \vdash A \text{ type} \quad \Delta \vdash \gamma : \Gamma.A}
{\Delta \vdash \gamma = (\mathbf{p}\circ \gamma).\mathbf{q}[\gamma] : \Gamma.A}
\]
\\
\end{tcolorbox} 

There rules are seemed to be very unclear. However, see following diagram. For first rule, 
\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]
We can represent the first rule as following way. 

\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma", red] \arrow[rd, "\gamma.a"', blue] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left, blue]
\end{tikzcd}
\]
So we can intuitively know that $\gamma$ and $\mathbf{p} \circ (\gamma.a)$ represent same traffic way from $\Delta$ to $\Gamma$. 
For second rule, we already explained in front page. When we meet $x_{n+1}$ (i.e. meet $q$ in $\Gamma.A$) 
then bring it from $\Gamma.A$ into $\Delta$ and substitute by $a$, term of $\Delta$. This rule explicitly claim this intuition. 
For third rule, let's draw slightly changed diagram. 

\[
\begin{tikzcd}
    \Delta  \arrow[rd, "\gamma"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]

Can we see what is $(\mathbf{p} \circ \gamma)$ here? We can draw 

\[
\begin{tikzcd}
    \Delta \arrow[r, "p\circ \gamma", red] \arrow[rd, "\gamma"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]

Now, see \ref{subst extend}. When we make $\mathbf{p} \circ \gamma : \Delta \rightarrow \Gamma$ to something that $\Delta \rightarrow \Gamma.A$, 
we append something to $\mathbf{p} \circ \gamma$. Here, actually the answer is already given. Suppose 
$q$ in $\Gamma.A$, it has type $A[\mathbf{p}]$ in $\Gamma.A$. We define $\gamma$ by, how we take variable $\mathbf{q}$ in $\Gamma.A$ to $\Delta$? 
Actually its answer is $\mathbf{q}[\gamma]$. It has type $A[\mathbf{p}][\gamma] = A[\mathbf{p} \circ \gamma]$ in $\Delta$. 
So to make same substitution with $\gamma$, we must append $\mathbf{q}[\gamma]$ at $\mathbf{p}\circ \gamma$. This intuition gives us $\gamma = (\mathbf{p}\circ \gamma).\mathbf{q}[\gamma]$ in $\Delta$. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.1]\hypertarget{Exer 2.1.}{}

Prove that if $\Gamma \vdash \gamma : \Gamma.A$, then $\mathbf{p} \circ \gamma = \textbf{id}$
\begin{proof}
    How can we define $\gamma$? The intuitive meaning of $\gamma$ is that, way to bring types and terms 
    of $\Gamma.A$ into $\Gamma$. Imagine that $\Gamma.A$ contains types of $x_1, \cdots, x_{n+1}$ and 
    $\Gamma$ contains types of $x_1, \cdots, x_n$. To bring types and terms in $\Gamma.A$ into $\Gamma$, only to do is when we meet $x_{n+1}$, substitute it with well-formed term in $\Gamma$ context. 
    By this way we can delete the appearance of $x_{n+1}$ and make types and terms in $\Gamma.A$ become types and terms in $\Gamma$. 
    So, $\gamma$ is defined by following way. This is construction \hyperlink{subst extend}{1.3.10.}
    \[
    \inferrule
    {\Gamma \vdash \textbf{id} : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma \vdash a : A}
    {\Gamma \vdash \underbrace{\textbf{id}.a}_{\gamma} : \Gamma.A}
    \]
    However, according to \hyperlink{construction 1.3.11}{construction 1.3.11} we can know that 
    \[\mathbf{p} \circ (\mathbf{id}.a) = \mathbf{id}\]
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.2]
Show that $(\gamma.a) \circ \delta = (\gamma \circ \delta).a[\delta]$

\begin{proof}
    Recall third rule in \hyperlink{construction 1.3.11}{construction 1.3.11.}, 
    \[
    \inferrule
    {\Gamma \vdash A \text{ type} \quad \Delta \vdash \gamma^* : \Gamma.A}
    {\Delta \vdash \gamma^* = (\mathbf{p}\circ \gamma^*).\mathbf{q}[\gamma^*] : \Gamma.A}
    \]
    Here, the pre-suppostions of problem is that $\Delta \vdash \gamma : \Gamma$, $\Delta \vdash a : A[\gamma]$, $\Gamma \vdash A \text{ type}$ and $\delta$ be any substitution $\delta : \Lambda \rightarrow \Delta$. 
    In diagram, 
    \[
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"] & \Gamma \\
        \Lambda \arrow[u, "\delta"] & \Gamma.A
    \end{tikzcd}
    \]
    (Continue in Next Page . . .)
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.2]
    For intuition, we can draw following substitution. 
    \[
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"] & \Gamma \\
        \Lambda \arrow[u, "\delta"] \arrow[r, "(\gamma.a)\circ \delta"', red] & \Gamma.A
    \end{tikzcd}
    \]
    And also, 
    \[
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"]  & \Gamma \\
        \Lambda \arrow[u, "\delta"] \arrow[ru, "\gamma \circ \delta", blue] & \Gamma.A
    \end{tikzcd}
    \implies 
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"]  & \Gamma \\
        \Lambda \arrow[u, "\delta"] \arrow[ru, "\gamma \circ \delta", blue] \arrow[r, "(\gamma \circ \delta).?"', blue] & \Gamma.A
    \end{tikzcd}
    \]
    Here our claim is that $?$ part is $a[\delta]$ and $(\gamma.a)\circ \delta = (\gamma \circ \delta).a[\delta]$. 
    At first, let 
    \[\gamma^* = (\gamma.a) \circ \delta\]
    Then $\Lambda \vdash \gamma^* : \Gamma.A$ because 
    \[
    \inferrule
    {\Lambda \vdash \delta : \Delta \quad \Delta \vdash \gamma.a : \Gamma.A}
    {\Lambda \vdash \underbrace{(\gamma.a) \circ \delta}_{\gamma^*} : \Gamma.A}
    \]
    So we can apply \hyperlink{construction 1.3.11}{construction 1.3.11.}
    \[
    \inferrule
    {\Gamma \vdash A \text{ type} \quad \Lambda \vdash (\gamma.a) \circ \delta : \Gamma.A}
    {\Lambda \vdash (\gamma.a) \circ \delta = \underbrace{(\mathbf{p} \circ ((\gamma.a) \circ \delta)).\mathbf{q}[(\gamma.a)\circ \delta]}_{(*)} : \Gamma.A}
    \]
    Here, our claim is that $(*) = (\gamma \circ \delta).a[\delta]$. This is because, 
    \begin{align*}
        & (\mathbf{p} \circ ((\gamma.a) \circ \delta)).\mathbf{q}[(\gamma.a)\circ \delta] \\
        & = ((\mathbf{p} \circ (\gamma.a)) \circ \delta).\mathbf{q}[(\gamma.a)\circ \delta] \\
        & = (\gamma \circ \delta).\mathbf{q}[(\gamma.a)\circ \delta] \\
        & = (\gamma \circ \delta).(\mathbf{q}[\gamma.a][\delta]) \\
        & = (\gamma \circ \delta).a[\delta]
    \end{align*}
    This is end of proof. 
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.3]\hypertarget{gamma.A}{}
    Given $\Delta \vdash \gamma : \Gamma$ and $\Gamma \vdash A \text{ type}$, construct $\gamma.A$ such that 
    $\Delta.A[\gamma] \vdash \gamma.A : \Gamma.A$. 
    \begin{proof}
        Actually, this is also very clear notion. Let's see following diagram. 
        \[
        \begin{tikzcd}
            \Delta \arrow[r, "\gamma"] & \Gamma \\
            \Delta.A[\gamma] \arrow[u, "p_\Delta"] & \Gamma.A
        \end{tikzcd}
        \]
        This implies that 
        \[
        \begin{tikzcd}
            \Delta \arrow[r, "\gamma"] & \Gamma \\
            \Delta.A[\gamma] \arrow[u, "p_\Delta"] \arrow[ru, "\gamma \circ p_\Delta", red] & \Gamma.A
        \end{tikzcd}
        \]
        And our intuition for $\gamma.A$ is that 
        \[
        \begin{tikzcd}
            \Delta \arrow[r, "\gamma"] & \Gamma \\
            \Delta.A[\gamma] \arrow[r, "\gamma.A", "(\gamma \circ p_\Delta).?"', blue] \arrow[u, "p_\Delta"] \arrow[ru, "\gamma \circ p_\Delta", red] & \Gamma.A
        \end{tikzcd}
        \]
        We can apply \hyperlink{subst extend}{substitution extend rule} here. 
        \[
        \inferrule
        {\Delta.A[\gamma] \vdash \gamma \circ \mathbf{p}_\Delta : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta.A[\gamma] \vdash \mathbf{q} : A[\gamma][\mathbf{p}_\Delta] = A[\gamma \circ \mathbf{p}_\Delta]}
        {\Delta.A[\gamma] \vdash (\gamma \circ \mathbf{p}_\Delta).\mathbf{q} : \Gamma.A}
        \]
        Actually, this is our construction for $\gamma.A$. 
        \[\gamma.A := (\gamma \circ \mathbf{p}).\mathbf{q}, \quad \gamma.A : \Delta.A[\gamma] \rightarrow \Gamma.A\]
    \end{proof}
\end{tcolorbox}

\newpage 

\chapter{Internalizing Judgemental Structure : $\Pi, \Sigma, \text{Eq}, \text{Unit}$}

\section{Basic Intuitions}\hypertarget{intuition-2.1.}{}

We noted that Dependent Type Theory is similar with First Order Logic. In first order logic, 
there exists notion of assignment $s$ in Interpretation $\mathfrak{A} = \left<|\mathfrak{A}|, I\right>$ and 
variants of assignments. Both are corresponds into context $\Gamma$ and substitution $\gamma$ in chapter 1. 
And then, what's the remaining things? Since dependent type is similar with FOL formulas, 
we need to construct intuition of correspondings between them. First, FOL terms are corresponds with \lq terms' in our system. 
Second, predicates are corresponds with \lq type(dependent type)' in our system. These are all what we talk about in previous chapter. 
Remain things are connectives, quantifiers, true and false. (And one specific predicate, equality judgement.) 
They are corresponds w.r.t. non-dependent connectives, dependent sum($\exists$), dependent product($\forall$), Unit and Void. 
\\

I'll try to make more clear between those similarity, in each section. Before that, let's claim the slogan for (any) these 
connective or quantifier constructors. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Slogan]\hypertarget{slogan}{}

Any such connectives or quantifiers in our system is given by claiming followings : 

\begin{enumerate}
    \item Natural Type-forming Operation
    \item Natural Isomorphism Relating that Type's terms to judgementally-determined structure. 
\end{enumerate}

\end{tcolorbox}

First one means that for each newly introduced types in this chapter, there are 
explicit and meta-level clear construct operation for such type. i.e. We must have the recipe of type. \\
Second one means that, if we collect all terms that have types that introduced here, then the set must have 
isomorphism (meta-level meaning) with external (meta-level) structure. 

\section{Dependent Sums}

First of all, let's make clear all the \hyperlink{intuition-2.1.}{intuitions} for dependent sum. 
\begin{enumerate}
    \item The type former of dependent sum is $\Sigma$. We'll define soon. 
    \item Dependent sum's judgementally-determined structure is \lq dependent pair'. 
    \item Dependent sum is similar to $\exists$. 
\end{enumerate}

What is dependent pair? Imagine following \lq type' in dependent type system. 
\[(n : Nat,\text{  } \text{Vec } A\text{ }n)\]
Actually, this is not matched with our construction of De Bruijn index. Matched version is that 
\[(Nat, \text{  } \text{Vec } A\text{ }\mathbf{q})\]
Then imagin the Curry-Howard corresponds here. The term of above type is like \lq one' specific example of above pair, for example
\[(2, [a, a'])\]
We can understand that this is proof for 
\[(\exists n : Nat)(\text{Vec }A\text{ n})\]
In this intuition, we say that dependent sum is similar to $\exists$. From now on, 
let's construct above intuitions explicitly by defining operations, isomorphisms, and rules. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.1. Natural Type Formal]
\[\Sigma_{\Gamma} : \left(\biguplus_{A \in Ty(\Gamma)}Ty(\Gamma.A)\right) \rightarrow Ty(\Gamma)\]
\end{tcolorbox}

The domain space's meaning is (1) choose valid type $A$ in $\Gamma$ context and (2) Under previous choose, choose valid type in $\Gamma.A$. 
Then the codomain space's meaning is that, by this $\Sigma_{\Gamma}$ operator, such pair become valid type in $\Gamma$. Then 
where is \lq Natural' ? It's intuitive meaning is that, we can feel free to choose context $\Gamma$ here. i.e. freely substitute and then change context, the 
operator's working does not changed. We can write above natural mapping as following inference rules. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.1. Natural Type Formal ( inference rule ver. )]
\begin{mathpar}
\inferrule
{\Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}}
{\Gamma \vdash \Sigma(A, B) \text{ type}}
\and   
\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}}
{\Delta \vdash \Sigma(A,B)[\gamma] = \Sigma(A[\gamma], B[\gamma.A]) \text{ type}}
\end{mathpar}    
\end{tcolorbox}

For the second rule, it can be not clear that why $B[\gamma.A]$ introduced. Let's draw the diagram. 
See \hyperlink{gamma.A}{this construction for $\gamma.A$}
\[
\begin{tikzcd}[column sep=huge, row sep=large]
    \Delta \arrow[r, "\gamma"] & \Gamma   \\
    \Delta.A[\gamma] \arrow[r, "\gamma.A"', red] & \Gamma.A
\end{tikzcd}
\]

We can pull-back $A$ form $\Gamma$ to $\Delta$ through $\gamma$. And note that $B$ is type in the $\Gamma.A$. So if we pulling back this into $\Delta.A[\gamma]$, 
using $\gamma.A$. So, the pull-backed type is $B[\gamma.A]$ in $\Delta.A[\gamma]$. It means that 
\[\Delta \vdash A[\gamma] \text{ type}, \quad \Delta.A[\gamma] \vdash B[\gamma.A] \text{ type}\]
Then the type-formal implies that 
\[\Delta \vdash \Sigma(A[\gamma], B[\gamma.A]) \text{ type}\]
And naturality means that, this type works same with $\Sigma(A, B)$ in $\Gamma$. So construct identity with 
it's pull-backed version $\Sigma(A, B)[\gamma]$ and above. 
\\

Then here, how can we define the isomorphism between \lq terms' that have $\Sigma(A,B)$ types and such meta-level notion of \lq pair'? See 

\[\iota_{\Gamma, A, B} : \text{Tm}(\Gamma, \Sigma(A,B)) \xrightarrow{\cong} \biguplus_{a \in \text{Tm}(\Gamma, A)}\text{Tm}(\Gamma, B[\mathbf{id}.a])\]
\\
Note that this is isomorphism on the \lq terms'. Right-hand side contain all dependent pairs (meta-level representation) and 
our goal is match our new type $\Sigma$ into that notion. This setting is just done at abstraction level. Now 
our interests are (1) How can we unfold above isomorphism explicitly, using inference rules? 
(2) Can we define $\iota_{\Gamma, A, B}, \iota_{\Gamma, A, B}^{-1}$ and round-trip among them 
preserves structures? (3) Do such constructions have naturality? \\

These are remain works in this chapter. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.16.]
Construct non-dependent pair type, with dependent sum $\Sigma$. 

\begin{proof}
    TODO
\end{proof}

\end{tcolorbox}

Now let's construct above isomorphisms explicitly. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.2.]
This is explicit un-packing of $\iota_{\Gamma, A, B}$ 
\[
\inferrule
{ \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)}
{ \Gamma \vdash \mathbf{fst}(p) : A}
\]
\[
\inferrule
{ \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)}
{ \Gamma \vdash \mathbf{snd}(p) : B[\mathbf{id.fst}(p)]}
\]
\end{tcolorbox}

Second construction is very genious. It gives us very good intuition. When $\Gamma \vdash p : \Sigma(A, B)$ is given, 
we can take first element $a$ of $p$ easily. And then, when we meet $\mathbf{q}$ in type $B$, 
automatically understand that it is $a$ we taken. By this we can write 
\[(2, [a_1, a_2]) : \Sigma(Nat, \mathbf{Vec} \text{ A }\mathbf{q})\]
Actually above type generally represents following intuitive type without variable names. 
\[(n\text{ : Nat}, \mathbf{Vec }\text{ A }\mathbf{n})\] 
\\
Then now, it's time to clarify the inverse isomorphism $\iota_{\Gamma, A, B}^{-1}$. Intuitive meaning of this isomorphism is that, 
connect each meta-level dependent pair terms into our type system. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.3.]

\[\iota_{\Gamma, A, B}^{-1} : \uplus_{a \in \text{Tm}(\Gamma, A)} \text{Tm}(\Gamma, B[\textbf{id}.a]) \longrightarrow \text{Tm}(\Gamma, \Sigma(A, B))\]

\[
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Gamma \vdash \textbf{pair}(a, b) : \Sigma(A, B)
}
\]

\end{tcolorbox}
I want to write some understanding for this construction. I think that most important one is 
that $b$ is absolutely term of $\Gamma$. So, we can't use exact term $a$ via $\mathbf{q}$ when express $b$. 
However, term $a$ is used when express type of $b$, without writing $a$ directly. This is very very similar with 
$\exists$ quantifier. Imagine that we have set of premises $\Gamma$. Let's interpret above inference rule. 
\begin{enumerate}
    \item Under premises $\Gamma$, we have proof of $A$ via $a$. 
    \item Under premises $\Gamma$ with $A$, claim $B$. 
    \item Under premises $\Gamma$, $b$ is proof of $B[\mathbf{id}.a]$. 
\end{enumerate}
These three Curry-Howard statements give us intuition about the result of inference rule. 
\begin{enumerate}
    \item There exists proof $a$ of $A$. By using this, we can prove $B[\textbf{id}.a]$ via $b$. 
    \item $\iff$ $(\exists x).(B[\textbf{id}.x])$ satisfiable. 
\end{enumerate}
Now second job is that claiming these two isomorphisms are symmetric. It means that 
the correspondings between our type system and meta-level dependent pair is bijective. Actually 
proving is done by constructing $\beta$-rule and $\eta$-rule. To show bijective, we just show that round-trip between 
terms and meta-pairs always preserve original element. Formally, we want to make 
\[\iota_{\Gamma, A, B} \circ \iota_{\Gamma, A, B}^{-1} = \textbf{id}_{\textbf{meta}}, \quad \iota_{\Gamma, A, B}^{-1} \circ \iota_{\Gamma, A, B} = \textbf{id}_{\textbf{term}}\]
\\
This is guaranteed explicitly via following rules. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.4.]
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)
}
{
    \Gamma \vdash \textbf{pair}(\textbf{fst}(p), \textbf{snd}(p)) = p : \Sigma(A, B)
}
\qquad \text{($\eta$-rule)}
\]
\begin{mathpar}
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Gamma \vdash \textbf{fst}(\textbf{pair}(a, b)) = a : A
}
\qquad \text{($\beta$-rule)}
\and   
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Gamma \vdash \textbf{snd}(\textbf{pair}(a, b)) = b : B[\textbf{id}.a]
}
\qquad \text{($\beta$-rule)}
\end{mathpar}
\end{tcolorbox}
Recap our ultimate goal. The last job is clarify that this isomorphism has naturality. \lq Naturality' means that 
we can freely use substitutions when apply this rule, or more easily, for all contexts, these pair structure is preserved. 
For this sake, we can make formal construction by rule also. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.5.]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Delta \vdash \textbf{pair}(a, b)[\gamma] = \textbf{pair}(a[\gamma], b[\gamma]) : \Sigma(A, B)[\gamma]
}
\]
\end{tcolorbox}
This is very intuitive. When we make $\textbf{pair}(a, b)$ toy in $\Gamma$, we have 2 ways to take that toy into $\Delta$ via $\gamma$. 
First way is that take the toy directly ($\textbf{pair}(a,b)[\gamma]$) and second way is that 
take two materials ($a[\gamma], b[\gamma]$) and make in $\Delta$ (then, $\textbf{pair}(a[\gamma], b[\gamma])$). This rule say that 
both are same. This is intuitive meaning of naturality. However, this is just naturality of $\iota_{\Gamma, A, B}^{-1}$. 
We need to show naturality of $\iota_{\Gamma, A, B}$ also. But this is derivable. 
\begin{align*}
    \textbf{fst}(p[\gamma]) &= \textbf{fst}(\textbf{pair}(\textbf{fst}(p), \textbf{snd}(p))[\gamma]) \\
    &= \textbf{fst}(\textbf{pair}(\textbf{fst}(p)[\gamma], \textbf{snd}(p)[\gamma])) \\
    &= \textbf{fst}(p)[\gamma]
\end{align*}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.17.]
Show that well-typedness of $b[\gamma]$ in Construction 2.2.5. 

\begin{proof}
    Our goal is showing that $\Delta \vdash b[\gamma] : B[\gamma.A][\textbf{id}.a[\gamma]]$(And this is well-formed type in $\Delta$ also). This is from 
    pattern-matching with Construction 2.2.3. 
    See following diagram first. 
    \[
    \begin{tikzcd}[column sep=huge]
        \Delta \arrow[r, "\gamma", blue] \arrow[d, "{id.a[\gamma]}"', red] \arrow[rd, "{\gamma.a[\gamma]}", purple] & \Gamma \arrow[d, "id.a"] \\
        \Delta.A[\gamma] \arrow[r, "\gamma.A", red] & \Gamma.A
    \end{tikzcd}
    \]
    Then see how can we take $B$ from $\Gamma.A$ to $\Delta$ and $b$ from $\Gamma$ to $\Delta$. 
    $B$ is pull-backed through red way and $b$ is pull-backed through blue way. So 
    $b[\gamma]$ is well-formed term in $\Delta$. And similary, $B[\gamma.A][\textbf{id}.a[\gamma]]$ is well-formed type in $\Delta$. 
    Last, we must show that $b[\gamma]$ has such type. Since we know that $\Gamma \vdash b : B[\textbf{id}.a]$, 
    it is clear that $\Delta \vdash b[\gamma] : B[\textbf{id}.a][\gamma]$. Then we can complete proof via showing 
    $\Delta \vdash B[\gamma.A][\textbf{id}.a[\gamma]] = B[\textbf{id}.a][\gamma] \text{ type}$. This holds because 
    \begin{align*}
        [\gamma.A][\textbf{id}.a[\gamma]] &= \gamma.A \circ (\textbf{id}.a[\gamma]) \\
        &= \gamma.a[\gamma] \qquad \text{$\because$ purple arrow above} \\
        &= (\textbf{id}.a) \circ \gamma \\
        &= [\textbf{id}.a][\gamma]
    \end{align*}
\end{proof}
\end{tcolorbox}

\newpage 

\section{Dependent Products}

Here also, follow up the constructing of previous chapter. We'll clarify intuition for this type by : 
\begin{enumerate}
    \item The type former of dependent product is $\Pi$. We'll define soon. 
    \item Dependent product's judgementrally-determined structure is \lq dependent function'. 
    \item Dependent product is similar to $\forall$. 
\end{enumerate}

Here, what is dependent function? Imagin following type in dependent type system. 
\[(n : Nat) \longrightarrow \textbf{Vec}\text{ }A \text{ }n\]
The term of above type works like a function, whose input is natural number $n$ and output is 
vector with length $n$. So this is very similar with $\forall$. Once we throw any natural number $n$, it returns 
proof of output type. i.e. this type is similar to claim that
\[(\forall n : Nat)(\textbf{Vec}\text{ }A\text{ }n)\]
\\
Recap the \hyperlink{slogan}{slogan}. When we introduce types here, we'll define (1) Natural Type Former and (2) Natural Isomorphisms between terms and external structure. 
As we've studied in previous chapter, we can expect what are them. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.1. Natural Type Formal]
\[\Pi_{\Gamma} : \left(\biguplus_{A \in Ty(\Gamma)} Ty(\Gamma.A)\right) \rightarrow Ty(\Gamma)\]
\end{tcolorbox}
And then, we can construct explicit rules for make this operator as same previous. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.2.]

\begin{mathpar}
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}
}
{
    \Gamma \vdash \Pi(A, B)\text{ type}
}
\and   
\inferrule 
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}
}
{
    \Delta \vdash \Pi(A, B)[\gamma] = \Pi(A[\gamma], B[\gamma.A]) \text{ type}
}
\end{mathpar}

\end{tcolorbox}

This is our \lq type former' for dependent product. Actually for understanding type forming, 
it isn't difficult since we deal samely in previous chapter. Now our goal is that, find and define 
natural isomorphisms between \lq terms' that have $\Pi(A, B)$ type and meta-level notion of \lq dependent function'. 
Imagine that following two sets are isomorphic. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.3. Natural Isomorphism of Terms]

\[Tm(\Gamma, \Pi(A, B)) \quad \cong \quad Tm(\Gamma.A, B)\]
And divide each isomorphism via 
\[\iota_{\Gamma, A \rightarrow B} : Tm(\Gamma, \Pi(A, B)) \xrightarrow{\cong} Tm(\Gamma.A, B)\]
\[\iota_{\Gamma, A \rightarrow B}^{-1} : Tm(\Gamma.A, B) \xrightarrow{\cong} Tm(\Gamma, \Pi(A, B))\]

\end{tcolorbox}

Now, let's do same construction with previous chapter. (1) How can we unfold above isomorphism explicitly, using inference rules? 
(2) Can we define $\iota_{\Gamma, A\rightarrow B}, \iota_{\Gamma, A\rightarrow B}^{-1}$ and 
round-trip among them presereves structures? (3) Do such constructions have naturality? 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.4.]\hypertarget{const 2.3.4.}{}
Let's unpack $\iota_{\Gamma, A\rightarrow B}$
\begin{mathpar}
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B)
}
{
    \Gamma \vdash \textbf{app}(f, a) : B[\textbf{id}.a]
}
\end{mathpar}
Let's unpack $\iota_{\Gamma, A\rightarrow B}^{-1}$
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash b : B
}
{
    \Gamma \vdash \lambda(b) : \Pi(A, B)
}
\]

\end{tcolorbox}

Both are very intuitive. First one is application of function, and second one is lambda-definition of function without variable name. 
However, I want to note some slight difference between dependent sum and above. 
One difference is that, place that $b$ exists. At dependent sum, $b$ exists in $\Gamma$ context. 
So we explain that we can't use $\mathbf{q}$ for express $a$ in $b$. However, at above, $b$ is term of $\Gamma.A$ world. So 
we can use $\mathbf{q}$ for represent $b$. This is one of major difference. Further, by this, we can 
agree our abstractical notion for matching of $\forall$ and $\Pi$. We can always take proof $b$ of $B$ under premises $\Gamma$ appended with $A$ by substitution $\textbf{id}.a$ for all $a$. 
It gives us that, with any proof $x$ of $A$, $B[\textbf{id}.x]$ is true. Formally, existance term of type $\Pi(A, B)$ is proof of
\[(\forall x).(B[\textbf{id}.x])\]

The next job is that claiming these two isomorphisms are symmetric. Similar to previous chapter, we need to define 
\[\iota_{\Gamma, A\rightarrow B}\circ \iota_{\Gamma, A\rightarrow B}^{-1} = \textbf{id}_{meta}, \quad \iota_{\Gamma, A\rightarrow B}^{-1} \circ \iota_{\Gamma, A\rightarrow B} = \textbf{id}_{term}\]
\\
This is guaranteed explicitly via following rules. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.5.]\hypertarget{const 2.3.5.}{}
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B)
}
{
    \Gamma \vdash \lambda(\textbf{app}(f[\mathbf{p}], \mathbf{q})) = f : \Pi(A, B)
}
\qquad \text{($\eta$-rule)}
\]
\[
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash b : B
}
{
    \Gamma \vdash \textbf{app}(\lambda(b), a) = b[\textbf{id}.a] : B[\textbf{id}.a]
}
\qquad \text{($\beta$-rule)}
\]
\end{tcolorbox}

Our final goal is state that this isomorphism has naturality. This can be holded by make following rules explicitly. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.6.]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}
}
{
    \Delta \vdash \Pi(A, B)[\gamma] = \Pi(A[\gamma], B[\gamma.A]) \text{ type}
}
\]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash b : B
}
{
    \Delta \vdash \lambda(b)[\gamma] = \lambda(b[\gamma.A]) : \Pi(A, B)[\gamma]
}
\]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B) 
}
{
    \Delta \vdash \textbf{app}(f, a)[\gamma] = \textbf{app}(f[\gamma], a[\gamma]) : B[\gamma.a[\gamma]]
}
\]
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.6.]
At Construction 2.3.6. prove that $\textbf{app}(f, a)[\gamma]$ and $\textbf{app}(f[\gamma], a[\gamma])$ have the type $B[\gamma.a[\gamma]]$. 

\begin{proof}
    Let's drow diagram, 
    \[
    \begin{tikzcd}[column sep = huge]
        \Delta \arrow[r, "\gamma"] \arrow[rd, "{\gamma.a[\gamma]}"] \arrow[d, "{id.a[\gamma]}"'] & \Gamma \arrow[d, "id.a"] \\
        \Delta.A[\gamma] \arrow[r, "\gamma.A"] & \Gamma.A
    \end{tikzcd}
    \]
    We can take $a$ form $\Gamma$ to $\Delta$, type $B$ from $\Gamma.A$ to $\Delta.A[\gamma]$, and take $f$ from $\Gamma$ to $\Delta$. It gives us 
    \[\Delta \vdash a[\gamma] : A[\gamma] \quad \Delta.A[\gamma] \vdash B[\gamma.A] \text{ type} \quad \Delta \vdash f[\gamma] : \Pi(A, B)[\gamma]\]
    Then by Construction 2.3.4. we can get 
    \[\Delta \vdash \textbf{app}(f[\gamma], a[\gamma]) : B[\gamma.A][\textbf{id}.a]\]
    However, we know that $B[\gamma.A][\textbf{id}.a] = B[\gamma.a[\gamma]]$, so 
    \[\Delta \vdash \textbf{app}(f[\gamma], a[\gamma]) : B[\gamma.a[\gamma]]\]
    And first one is easier, we can take $\textbf{app}(f, a) : B[\textbf{id}.a]$ from $\Gamma$ into $\Delta$. 
    \[\Delta \vdash \textbf{app}(f, a)[\gamma] : B[\textbf{id}.a][\gamma] = B[(\textbf{id}\circ \gamma).a[\gamma]] = B[\gamma.a[\gamma]]\]
\end{proof}

\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.7.]
At Construction 2.3.5. prove that $\lambda(\textbf{app}(f[\mathbf{p}], \mathbf{q}))$ is well-formed term of $\Pi(A, B)$ in $\Gamma$. 
\begin{proof}
    Our goal is showing 
    \[\Gamma \vdash \lambda(\textbf{app}(f[\textbf{p}], \textbf{q})) : \Pi(A, B)\]
    To this is valid, we need 2 premises 
    \[\Gamma \vdash A \text{ type}, \qquad \Gamma.A \vdash \textbf{app}(f[\textbf{p}], \textbf{q}) : B\]
    First one is premised, so let's prove second one. Since $f$ is term of $\Gamma$, so take it to $\Gamma.A$ then $f[\textbf{p}]$. So, 
    we know that 
    \[\Gamma.A \vdash f[\textbf{p}] : \Pi(A, B)[\textbf{p}], \quad \Gamma.A \vdash \textbf{q} : A[\textbf{p}], \qquad \Gamma.A.A[\textbf{p}] \vdash B[\textbf{p}.A] \text{ type}\]
    Then with Construction 2.3.4. we can get 
    \[\Gamma.A \vdash \textbf{app}(f[\textbf{p}], \textbf{q}) : B[\textbf{p}.A][\textbf{id.q}]\]
    Then remain thing to show is 
    \[\Gamma.A \vdash B = B[\textbf{p}.A][\textbf{id.q}] \text{ type}\]
    Actually, this is intuitive. $\textbf{p}.A$ is weakening from $\Gamma.A$ into $\Gamma.A.A[\textbf{p}]$. So it is just 
    send $B$ in $\Gamma.A$ to $\Gamma.A.A[\textbf{p}]$ and take it again through $\textbf{id.q}$. Formal writing is that, 
    \[B[\textbf{p}.A][\textbf{id.q}] = B[\textbf{p}.A \circ \textbf{id.q}] = B[(\textbf{p}\circ \textbf{id}).\textbf{q}] = B[\textbf{p.q}] = B\]
    This is end of proof. 
\end{proof}
\end{tcolorbox}
Here, I'll add some intuition, introduced in page 41 of textbook. Recap the natural isomorphism, 
such that terms whose type is $\Pi(A, B)$ in $\Gamma$ and terms whose type is $B$ in $\Gamma.A$. 
\[Tm(\Gamma, \Pi(A, B)) \cong Tm(\Gamma.A, B)\]
\\
Here, we can easily understand the inverse isomorphism $\iota^{-1}_{\Gamma, A\rightarrow B}$. It is 
similar to pull-back $b$ which is term of type $B$ in $\Gamma.A$ into $\Gamma$ context by unknown extending $\mathbf{id}.?$. 
It is denoted by $\lambda(b)$. However, when we see $\iota_{\Gamma, A \rightarrow B}$, the meaning of this 
map is send $\Gamma \vdash f : \Pi(A, B)$ into term of type $B$ in $\Gamma.A$. However, we introduced the forward map via \hyperlink{const 2.3.4.}{const 2.3.4.}, 
\[
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B)
}
{
    \Gamma \vdash \mathbf{app}(f, a) : B[\mathbf{id}.a]
}
\]
\\
It is quite un-expectable. Because in our intuition, forward isomorphism's range space is $\Gamma.A$. 
If we follow that, our $\mathbf{app}$ maybe $\Gamma.A \vdash \mathbf{app}^*(f[\mathbf{p}], \mathbf{q})$. 
This is also valid construction of elimination rule for $\Pi$-type. And also this is intuitively understandable, 
however this form of definition of application is not familiar to us. Most of time, we imagine 
application via $f(a), \mathbf{f}(a)$ this form. This is reason why we use above form of $\mathbf{app}$ definition. 
When we move from context $\Gamma$ to $\Gamma.A$, we always give $\Gamma \vdash a : A$, and $\mathbf{app}^*$ automatically 
has the intension that we'll use such ghost $a$. For convenience, our intension introducing here is that, externally 
mension such $a$ we use. Then pull-back $\mathbf{app}^*(f[\mathbf{p}], \mathbf{q})$ into $\Gamma$ by $\mathbf{id}.a$, 
we can get above form of $\mathbf{app}$ definition. 

\newpage  

\section{Extensional Equality}

Actually, the constructing for here is very simple and similar to previous sections. However, there are many 
remarkable stuffs about what \lq equality' means. Because we already use a kind of equality many times. Recap 
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)
}
{
    \Gamma \vdash \mathbf{pair}(\mathbf{fst}(p), \mathbf{snd}(p)) = p : \Sigma(A, B)
}
\]
\\
Here we already used \lq =' symbol which means equality. This kind of equality is called definitional equality. 
This equality is part of constructing definition of pair. (Especially, $\eta$-rule for define validity of $\iota^{-1}_{\Gamma, A, B}$) 
One good example to understand this is that, 

\begin{lstlisting}[language=Caml, caption={Add in Peano Arithmetic}, label={lst:ocaml}]
    let rec Add(n : Nat, m : Nat) = 
        match (n, m) with 
        | (n, 0) -> n 
        | (n, succ m') -> Succ(Add(n, m'))
\end{lstlisting}
\vspace{4mm}
In this case, $Add(n, 0)$ and $n$ are definitionally equal. Similarly, $Add(n, 2)$ and $Succ(Succ(n))$ also definitionally equal. 
However, what about $Add(n, m)$ and $Add(m, n)$? We(meta-level) know that they are equal, but we need some proof. 
It does not follows directly from definition. Such \lq provable' equality is called propositional equality. (or called extensional equality) 
Main target of this section is bring those equality between terms into our type system. Recap the Curry-Howard corresponding, 
we'll bring such \lq provable proposition' as a $\mathbf{Eq}$ type in our system, and if there is a term $p$ 
of type $\mathbf{Eq}$ exists, then it is proof for such proposition. Let's get started. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.4.1. Natural Type Formal]
\[\mathbf{Eq}_\Gamma : \left(\biguplus_{A \in Ty(\Gamma)} Tm(\Gamma, A) \times Tm(\Gamma, A) \right) \rightarrow Ty(\Gamma)\]
\end{tcolorbox}
\vspace{4mm}
The un-packed version of above intuition is that, 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.4.2.]\hypertarget{const 2.4.2.}{}
\begin{mathpar}
\inferrule
{
    \Gamma \vdash a, b : A 
}
{
    \Gamma \vdash \mathbf{Eq}(A, a, b) \text{ type}
}
\and  
\inferrule 
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a, b : A
}
{
    \Delta \vdash \mathbf{Eq}(A, a, b)[\gamma] = \mathbf{Eq}(A[\gamma], a[\gamma], b[\gamma]) \text{ type}
}
\end{mathpar}
\end{tcolorbox}
\vspace{4mm}
Thanks for the previous works, it is not hard to understand. This is our natural type formal $\mathbf{Eq}$. However something is quite different for defining natural isomorphisms. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.4.3.]\hypertarget{const 2.4.3.}{}
\[Tm(\Gamma, \mathbf{Eq}(A, a, b)) \cong \mathbb{E}_{a \equiv b} := \begin{cases}
    \{*\} & a \equiv b \\
    \emptyset & a \not\equiv b
\end{cases}\]
And divide each isomorphism via 
\[\iota_{\Gamma, A, a \equiv b} : Tm(\Gamma, \mathbf{Eq}(A, a, b)) \xrightarrow{\cong} \mathbb{E}_{a\equiv b}\]
\[\iota_{\Gamma, A, a \equiv b}^{-1} : \mathbb{E}_{a \equiv b} \xrightarrow{\cong} Tm(\Gamma, \mathbf{Eq}(A, a, b))\]
\end{tcolorbox}
\vspace{4mm}
This isomorphic target is $\mathbb{E}_{a\equiv b}$, quite unclear now. Here, I wrote $\equiv$ symbol to mean propositional equality. 
We can interpret above isomorphism in natural language, by \lq If two terms $a, b$ of type $A$ in $\Gamma$ are propositionally equal, 
then there exists a unique proof (term) for such propositional equality $\mathbf{Eq}(A, a, b)$ and if not, 
there aren't any proof (term) for that.' Then now let's unpack above isomorphisms explicitly. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.4.4.]\hypertarget{const 2.4.4.}{}
Unpacking $\iota_{\Gamma, A, a\equiv b}$ : 
\begin{mathpar}
\inferrule
{
    \Gamma \vdash a, b : A \quad \Gamma \vdash p : \mathbf{Eq}(A, a, b) 
}
{
    \Gamma \vdash a = b : A 
}
\and  
\inferrule
{
    \Gamma \vdash a, b : A \quad \Gamma \vdash p : \mathbf{Eq}(A, a, b)
}
{
    \Gamma \vdash \mathbf{refl} = p : \mathbf{Eq}(A, a, b)
}
\end{mathpar}
\vspace{4mm}
Unpacking $\iota_{\Gamma, A, a\equiv b}^{-1}$ : 
\[
\inferrule
{
    \Gamma \vdash a : A 
}
{
    \Gamma \vdash \mathbf{refl} : \mathbf{Eq}(A, a, a)
}
\]
\end{tcolorbox}

\vspace{4mm}

First rule implies that, if there exists proof of equality, we can use that as definitional equality, i.e. rewrite anywhere, anytime. 
And second rule implies that such proof is unique. These two rules cosntruct forward isomorphism. However, 
third rule is kind of unique term-generator. Note that all of basic definition equalities are included here. 
We can understand this rule as visualization of $a$-quotient in meta-space. Our textbook write down the power of this type : 
(1) If there exists a proof for $a \equiv b$, i.e. $\Gamma \vdash p : \mathbf{Eq}(A, a, b)$ then we can always, anywhere rewrite $a$ to $b$ and $b$ to $a$. 
(2) Proof $p$ can be a variable. Imagine the context $\Gamma.\mathbf{Eq}(A, a, b)$. \\
However, this is dangerous since pull propositional equality into definitional equality. This is main feature of extensional type system. However, 
it can break the decidablity of type-checker. 

\newpage 

\section{Unit Type}

This is the last, and the most simple type in chapter 2. Intuitive meaning of this type is \textbf{true} in logic. 
Imagine some functions in OCaml, which have type $\mathbf{Unit} \rightarrow ..$ 
We can always excute this function without any input ( premises ) , so the functionality of unit type is 
true in logic. Since the constructions are simple, I'll write down without detailed explaining. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.5.1.]\hypertarget{const 2.5.1.}{}
\[\mathbf{Unit}_\Gamma \in Ty(\Gamma)\]
\[Tm(\Gamma, \mathbf{Unit}) \cong \{*\}\]
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.5.2.]\hypertarget{const 2.5.2.}{}
\begin{mathpar}
\inferrule
{
    \vdash \Gamma \text{ cx}
}
{
    \Gamma \vdash \mathbf{Unit} \text{ type}
}
\and  
\inferrule 
{
    \Delta \vdash \gamma : \Gamma   
}
{
    \Delta \vdash \mathbf{Unit}[\gamma] = \mathbf{Unit} \text{ type}
}
\end{mathpar}
\begin{mathpar}
\inferrule
{
    \vdash \Gamma \text{ cx}
}
{
    \Gamma \vdash \mathbf{tt} : \mathbf{Unit}
}
\and  
\inferrule
{
    \Gamma \vdash a : \mathbf{Unit}
}
{
    \Gamma \vdash a = \mathbf{tt} : \mathbf{Unit}
}
\end{mathpar}
\end{tcolorbox}
\newpage 
\chapter{Inductive Types \\ : Void, Bool, +, Nat}

\section{Basic Intuitions}

Inductive types are types defined via induction principles. Our previous discussion is \lq For given context $\Gamma$, let's define natural type $\Upsilon$. 
It's structure is similar to some external meta-level structure. i.e. $Tm(\Gamma, \Upsilon) \cong ...$' 
Our textbook introduce this kind of term constructing as \lq hard coded' type formers. 
However, in this chapter, our discussion is entirely changed as \lq First, let's define type former $\Upsilon$. 
Second, assume that our interesting context already has such type by $\Gamma.\Upsilon$. 
Third, in such context $\Gamma.\Upsilon$, what's going on terms of well-defined type $A$ in $\Gamma.\Upsilon$?' 
This flow is sufficiently seemed like inductive definitions. Although we get such kind of intuitions, 
it can be still not familiar for us that defining types and connecting them with its natural meta-level structures via $Tm(\Gamma.\Upsilon, A) \cong ...$
So, textbook also gives us some set-theorical intuitions. I'll introduce such thing in this chapter first. 

Suppose that $A, B$ are sets. Can you define the Cartesian product $A \times B$ of $A, B$? 
The answer might be $A \times B := \{(a, b) | a \in A , b \in B\}$. Correct, however there are alternative way to defining $A \times B$. Actually it is characterize of set $A \times B$. 
We now define $A \times B$ via \textbf{for any set $X$, if any $f : X \rightarrow A \times B$ is given, 
then $f_1 : X \rightarrow A$ and $f_2 : X \rightarrow B$ are also determined and vice versa.} 
Here, the symbol $A \times B$ such that holds above bold \textbf{charactiristic} is definition of Cartesian product of $A, B$. 
( More rigorously, such isomorphic quotients are $A \times B$. )

Another example is characterize of single-ton set $\mathbf{1}$. One way for definition is construct isomorphic quotient 
$\mathbf{1} \cong \{*\}$. However it can be characterize by following way : \textbf{For any set $X$, there are only one function $X \rightarrow \mathbf{1}$. i.e. $\forall X, |Hom(X, \mathbf{1})| = 1$}
All these kind of construction is what we did in previous chapter. Look similarity between 
\[Hom(X, \mathbf{1}) \cong Tm(\Gamma, \mathbf{Unit})\]

Now let's define emptyset $\emptyset$ like this kind of construction. One turns out that, the most elegant characterization of $\emptyset$ is 
\textbf{For any set $X$, there are only one function $\emptyset \rightarrow X$}. This is story about, 
why we put our target in left blank. 

\newpage 

\section{Void : The empty type}

Poetically, \textbf{Void} type's role is \textbf{false} in first order logic, and \textbf{emptyset} in set theory. 
When we prove something in first order logic, if we reach $ I \models \bot$ under assuming $I \models \Gamma$, 
then we say that $\Gamma$ is false, or $I \not\models \Gamma$. Very similar role is done by \textbf{Void}. 
If we reach well-defined term $\Gamma \vdash b : \mathbf{Void}$, then it is proof that our context $\Gamma$ is wrong. i.e. Un-reachable context. 
Means that, \textbf{Void} type works like false proposition. 

Then now, the construction of type former is not difficult. It is same as \textbf{Unit} in previous chapter. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.2.1. Natural Type Formal]\hypertarget{const 3.2.1.}{}

\[\mathbf{Void}_\Gamma \in Ty(\Gamma)\]

\end{tcolorbox}
\vspace{2mm}
And also, easily unpack this meta-level representation into our type system by explicit rules. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.2.2.]\hypertarget{const 3.2.2.}{}
\begin{mathpar}
\inferrule
{
    \vdash \Gamma \text{ cx}
}
{
    \Gamma \vdash \mathbf{Void} \text{ type}
}
\and
\inferrule
{
    \Delta \vdash \gamma : \Gamma
}
{
    \Delta \vdash \mathbf{Void}[\gamma] = \mathbf{Void} \text{ type}
}
\end{mathpar}
\end{tcolorbox}
\vspace{4mm}

Defining natural type formal is similar to previous. If we are living in Chapter 2, the basic next step will be 
trying to construct following isomorphism : 
\[Tm(\Gamma, \mathbf{Void}) \cong \emptyset \qquad \text{$\Leftarrow$ (This is Wrong !!!)}\]
\\
If we append this isomorphism into our system, it will be rejected. This isomorphism doesn't agree with us
because 2 major reasons, First is that even wrong context $\Gamma$ also couldn't have \textbf{Void} type term. 
Second one is that, our already existing rules generate \textbf{Void} type terms, so the isomorphism between emptyset will be broken. 
The broken cases are following : $\mathbf{q} \in Tm(\Gamma.\mathbf{Void}, \mathbf{Void})$, and $\mathbf{app}(\mathbf{q}, \mathbf{tt}) \in Tm(\Gamma.\Pi(\mathbf{Unit}, \mathbf{Void}), \mathbf{Void})$. 
By those reasons, setting above isomorphism is disgusting. 

Then it's time to think like previous intuition section. \textbf{If Void type is existing our context already, then 
it can have terms for that type!! Moreover, in such context, Everything is Wrong !!} So does not try to construct as 
\lq \textbf{Void} is type characterized by, for any context $\Gamma$, no terms... Uh! It broke everything!' and 
try to \lq \textbf{Void} is type characterized by, if our context have \textbf{Void} already, then everything is false!' 
So let's imagine following isomorphism : 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.2.3. Natural Term Isomorphism]\hypertarget{const 3.2.3.}{}
\[\rho_{\Gamma, A} : Tm(\Gamma.\mathbf{Void}, A) \cong \{*\}\] 
\end{tcolorbox}

This isomorphism has interesting meanings, first one is that if our context contains \textbf{Void}, 
then for every type $A$ and terms of type $A$ is single-ton, which means that \lq false'. 
Another one is that, recap the isomorphic structure of dependent product type $\Pi$. 
\[Tm(\Gamma, \Pi(A, B)) \cong Tm(\Gamma.A, B)\]
\\
Under this, we can state 
\[Tm(\Gamma, \Pi(\mathbf{Void}, A)) \cong Tm(\Gamma.\mathbf{Void}, A) \cong \{*\}\]
\\
All dependent function that domain type is $\mathbf{Void}$ is single-ton element. 
Now our goal is that : bring this notion into our type system explicitly via rules. Approach one, 
bring above isomorphism \lq directly' , means that 
\begin{mathpar}
\inferrule
{
    \vdash \Gamma \text{ cx} \quad \Gamma.\mathbf{Void} \vdash A \text{ type}
}
{
    \Gamma.\mathbf{Void} \vdash \mathbf{absurd'} : A
}
\and  
\inferrule
{
    \vdash \Gamma \text{ cx} \quad \Gamma.A \vdash a : A 
}
{
    \Gamma.\mathbf{Void} \vdash \mathbf{absurd'} = a : A 
}
\end{mathpar}
We bring the isomorphism literally. However, recap what we did when handle \textbf{app} construction, 
we've liked represent the constructed term in $\Gamma$ context. However, above rules 
represents the constructed terms are in $\Gamma.\mathbf{Void}$. So, we'll axiomatization that 
\begin{tikzcd}
    \Gamma \arrow[r, "id.b"] & \Gamma.\mathbf{Void}
\end{tikzcd}
so get $\mathbf{absurd}(b) := \mathbf{absurd'}[\mathbf{id}.b]$ where $\Gamma \vdash b : \mathbf{Void}$
So we write cut-in version of term (proof for false) construction rules : ( These rules automatically infer the above rules, checking will be proved later as exercise. )

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.2.4.]\hypertarget{const 3.2.4.}{}
\[
\inferrule
{
    \Gamma \vdash b : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash A \text{ type}
}
{
    \Gamma \vdash \mathbf{absurd}(b) : A[\mathbf{id}.b]
}
\]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash b : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash A \text{ type}
}
{
    \Delta \vdash \mathbf{absurd}(b)[\gamma] = \mathbf{absurd}(b[\gamma]) : A[\gamma.b[\gamma]]
}
\]
\[
\inferrule
{
    \Gamma \vdash b : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash a : A 
}
{
    \Gamma \vdash \mathbf{absurd}(b) = a[\mathbf{id}.b] : A[\mathbf{id}.b]
}
\]
\end{tcolorbox}
\vspace{4mm}
Understanding above is not difficult. Note that the meaning \lq inductive' is well-expressed in here. 
We used type \textbf{Void} for premise of term constructor. So it is called inductive type. 
First rule tells us that, if we have a proof of false, then if we assume this as premise, then 
everything can be derived. Just the symbol \textbf{absurd}$(b)$ is proof of \lq every statements is false when we assume $b$'. 
Second one gives naturality for the term constructor. Third rule guarantees the single-toness of proof of $A$ in $\Gamma.\mathbf{Void}$. 

Now, with Exercises we'll make stronger understanding. 

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 3.2.5.]\hypertarget{const 3.2.5.}{}
Show that if $\Gamma \vdash b_0, b_1 : \mathbf{Void}$ then $\Gamma \vdash b_0 = b_1 : \mathbf{Void}$. 
\begin{proof}
    
First, we can get 
\[
\inferrule
{
    \Gamma.\mathbf{Void} \vdash \mathbf{p} : \Gamma \quad \Gamma \vdash b_0, b_1 : \mathbf{Void}
}
{
    \Gamma.\mathbf{Void} \vdash b_0[\mathbf{p}], b_1[\mathbf{p}] : \underbrace{\mathbf{Void}[\mathbf{p}]}_{ = \mathbf{Void}}
}
\]
Then, $\eta$-rule in \hyperlink{const 3.2.4.}{const 3.2.4.} implies that 
\[
\inferrule
{
    \Gamma \vdash b_0, b_1 : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash b_0[\mathbf{p}], b_1[\mathbf{p}] : \mathbf{Void}
}
{
    \Gamma \vdash \mathbf{absurd}(b_0) = b_0[\mathbf{p}][\mathbf{id}.b_0] : \mathbf{Void}[\mathbf{id}.b_0] \\
    \Gamma \vdash \mathbf{absurd}(b_0) = b_1[\mathbf{p}][\mathbf{id}.b_0] : \mathbf{Void}[\mathbf{id}.b_0] \\
    \Gamma \vdash \mathbf{absurd}(b_1) = b_0[\mathbf{p}][\mathbf{id}.b_1] : \mathbf{Void}[\mathbf{id}.b_1] \\
    \Gamma \vdash \mathbf{absurd}(b_1) = b_1[\mathbf{p}][\mathbf{id}.b_1] : \mathbf{Void}[\mathbf{id}.b_1]
}
\]
However, \hyperlink{Exer 2.1.}{Exer 2.1.} implies that $\Gamma \vdash \mathbf{p} \circ (\mathbf{id}.b_0) = \mathbf{p} \circ (\mathbf{id}.b_1) = \mathbf{id}$, 
and since $\Gamma \vdash \mathbf{Void}[\mathbf{id}.b_0] = \mathbf{Void}[\mathbf{id}.b_1] = \mathbf{Void}$
We can get 
\[
\Gamma \vdash \mathbf{absurd}(b_0) = b_0 = \mathbf{absurd}(b_1) = b_1 : \mathbf{Void}
\]
This implies that 
\[\Gamma \vdash b_0 = b_1 : \mathbf{Void}\]
So, this intuitively gives us that $\mathbf{Void}$ term is always single-ton if it exists. 
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 3.2.6.]\hypertarget{const 3.2.6.}{}
Fixing $\Delta \vdash \gamma : \Gamma$, prove that there is at most one substitution $\Delta \vdash \overline{\gamma} : \Gamma.\mathbf{Void}$ such that satisfying $\mathbf{p} \circ \overline{\gamma} = \gamma$. 
\begin{proof}
I'll draw diagram for good understanding. 
\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma"] \arrow[rd, "\overline{\gamma}"']& \Gamma \arrow[d, "?"', shift right]
    \\ & \Gamma.\mathbf{Void} \arrow[u, "p"', shift right]
\end{tikzcd}
\]
We'll use following rule for substitution : 
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Delta \vdash \gamma : \Gamma.A 
}
{
    \Delta \vdash \gamma = (\mathbf{p} \circ \gamma).\mathbf{q}[\gamma] : \Gamma.A
}
\tag{*}
\]
Suppose that $\overline{\gamma}_i, i = 1, 2$ such that $\Delta \vdash \overline{\gamma_i} : \Gamma.\mathbf{Void}, i = 1,2$ and $(\mathbf{p} \circ \overline{\gamma}_i) = \gamma, i = 1, 2$ exists. 
Then we can apply (*) by 
\[
\inferrule
{
    \Gamma \vdash \mathbf{Void} \text{ type} \quad \Delta \vdash \overline{\gamma}_i : \Gamma.\mathbf{Void}
}
{
    \Delta \vdash \overline{\gamma}_i = (\mathbf{p} \circ \overline{\gamma}_i).\mathbf{q}[\overline{\gamma}_i] : \Gamma.\mathbf{Void}
}
\]
By assumption, we can directly rewrite above result by 
\[\Delta \vdash \overline{\gamma}_i = \gamma.\mathbf{q}[\overline{\gamma}_i] : \Gamma.\mathbf{Void}\tag{**}\]
\\
However, $\Gamma.\mathbf{Void} \vdash \mathbf{q} : \mathbf{Void}$. So, we can pull-back $\mathbf{q}$ through $\overline{\gamma}_i$. 
\[
\inferrule
{
    \Delta \vdash \overline{\gamma}_i : \Gamma.\mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash \mathbf{q} : \mathbf{Void}
}
{
    \Delta \vdash \mathbf{q}[\overline{\gamma}_i] : \mathbf{Void}[\overline{\gamma}_i] = \mathbf{Void}
}
\]
However, the result of Exercise 2.23. implies that, 
\[\Delta \vdash \mathbf{q}[\overline{\gamma}_1] = \mathbf{q}[\overline{\gamma}_2] : \mathbf{Void}\]
\\
We can use this result for (**). 
\[\Delta \vdash \overline{\gamma}_1 = \gamma.\mathbf{q}[\overline{\gamma}_1] = \gamma.\mathbf{q}[\overline{\gamma}_2] = \overline{\gamma}_2 : \Gamma.\mathbf{Void}\]
This implies that, 
\[\Delta \vdash \overline{\gamma}_1 = \overline{\gamma}_2 : \Gamma.\mathbf{Void}\]
We proved that, if such $\overline{\gamma}$ exists, then it is unique. This is sufficient to prove that 
there is at most one such $\overline{\gamma}$. 

\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 3.2.7.]\hypertarget{const 3.2.7.}{}
Let $\Gamma.\mathbf{Void} \vdash A \text{ type}$ and $\Gamma \vdash a : A[\mathbf{id}.b]$. Show that 
$\Gamma.\mathbf{Void} \vdash A[(\mathbf{id}.b) \circ \mathbf{p}] = A \text{ type}$, and therefore that $\Gamma.\mathbf{Void} \vdash a[\mathbf{p}] : A$. 

\begin{proof}
    
We'll use following previous result. 
\[(\gamma.a) \circ \delta = (\gamma \circ \delta).a[\delta]\]
\\
In this exercies, we can write as 
\[(\mathbf{id}.b) \circ \mathbf{p} = (\mathbf{id} \circ \mathbf{p}).b[\mathbf{p}]\]
\\
However, by property of $\mathbf{id}$, 
\[(\mathbf{id}.b) \circ \mathbf{p} = (\mathbf{id} \circ \mathbf{p}).b[\mathbf{p}] = \mathbf{p}.b[\mathbf{p}]\tag{*}\]
However, our problem gives some pre-supposition : 
\[\Gamma \vdash A[\mathbf{id}.b] \text{ type}\]
Which means that 
\[\Gamma \vdash \mathbf{id}.b : \Gamma.\mathbf{Void}\]
This also gives pre-supposition : 
\[\Gamma \vdash b : \mathbf{Void}\]
So we can pull-back such $b$ through $\mathbf{p}$ : 
\[\Gamma.\mathbf{Void} \vdash b[\mathbf{p}] : \mathbf{Void}[\mathbf{p}] = \mathbf{Void}\]
However, $\Gamma.\mathbf{Void} \vdash \mathbf{q} : \mathbf{Void}$ and Exercise 2.23. implies that 
\[\Gamma.\mathbf{Void} \vdash b[\mathbf{p}] = \mathbf{q} : \mathbf{Void}\]
Then we can rewrite (*) by 
\[\]\[(\mathbf{id}.b) \circ \mathbf{p} = (\mathbf{id} \circ \mathbf{p}).b[\mathbf{p}] = \mathbf{p}.b[\mathbf{p}] = \mathbf{p}.\mathbf{q} = \mathbf{id}\]
in context $\Gamma.\mathbf{Void}$. So we can prove our original claim, 
\[\Gamma.\mathbf{Void} \vdash A[(\mathbf{id}.b) \circ \mathbf{p}] = A[\mathbf{id}] = A \text{ type}\]
Then the remaining part is easy. Since $\Gamma \vdash a : A[\mathbf{id}.b]$, we can pull-back $a$ into $\Gamma.\mathbf{Void}$ through $p$ : 
\[\Gamma.\mathbf{Void} \vdash a[\mathbf{p}] : A[\mathbf{id}.b][\mathbf{p}] = A[(\mathbf{id}.b)\circ \mathbf{p}] = A\]
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 3.2.8.]\hypertarget{const 3.2.8.}{}
Derive the following rule, using the previous exercise and the $\eta$-rule. 
\[
\inferrule
{
    \Gamma \vdash b : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash A \text{ type} \quad \Gamma \vdash a : A[\mathbf{id}.b]
}
{
    \Gamma \vdash a = \mathbf{absurd}(b) : A[\mathbf{id}.b]
}
\]

\begin{proof}

We'll use above Exercise 2.25. as lemma. We proved that 
\[
\inferrule
{
    \Gamma \vdash b : \mathbf{Void} \quad  \Gamma.\mathbf{Void} \vdash A \quad \text{ type} \quad \Gamma \vdash a : A[\mathbf{id}.b]
}
{
    \Gamma.\mathbf{Void} \vdash a[\mathbf{p}] : A
}
\tag{*}
\]
And the original $\eta$-rule is that 
\[
\inferrule
{
    \Gamma \vdash b : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash a : A 
}
{
    \Gamma \vdash \mathbf{absurd}(b) = a[\mathbf{id}.b] : A[\mathbf{id}.b]
}
\]
To apply this, let's write that 
\[
\inferrule
{
    \Gamma \vdash b : \mathbf{Void} \quad \Gamma.\mathbf{Void} \vdash a[\mathbf{p}] : A 
}
{
    \Gamma \vdash \mathbf{absurd}(b) = a[\mathbf{p}][\mathbf{id}.b] : A[\mathbf{id}.b]
}
\]
Since (*) gives the premises, we get 
\[\Gamma \vdash \mathbf{absurd}(b) = a[\mathbf{p}][\mathbf{id}.b] : A[\mathbf{id}.b]\]
However, $a[\mathbf{p}][\mathbf{id}.b] = a[\mathbf{p}\circ (\mathbf{id}.b)] = a[\mathbf{id}] = a$, we can get 
\[\Gamma \vdash  \mathbf{absurd}(b) = a : A[\mathbf{id}.b]\]
This is End of Proof. 
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 3.2.9.]\hypertarget{const 3.2.9.}{}
We have included the rule $\Delta \vdash \mathbf{absurd}(b)[\gamma] = \mathbf{absurd}(b[\gamma]) : A[\gamma.b[\gamma]]$ but 
it is in fact derivable using the $\eta$-rule. Prove this. 

\begin{proof}
Our assumptions here is that : $\Delta \vdash \gamma : \Gamma$ , $\Gamma \vdash b : \mathbf{Void}$, $\Gamma.\mathbf{Void} \vdash A \text{ type}$.
Let's draw the diagram first. 

\[\begin{tikzcd}[row sep = huge, column sep = huge]
    \Delta  \arrow[r, "\gamma"] & \Gamma   \\
    \Delta.\mathbf{Void} \arrow[r, red, "\gamma.\mathbf{Void}"] & \Gamma.\mathbf{Void} \arrow[u, "p"]
\end{tikzcd}\]

Then, since $\Gamma \vdash b : \mathbf{Void}$, we can pull-back into $\Delta$ : 
\[\Delta \vdash b[\gamma] : \mathbf{Void}\]
and since we've defined that $\Gamma \vdash \mathbf{absurd}(b) : A[\mathbf{id}.b]$, we can pull-back this into $\Gamma.\mathbf{Void}$ and again into $\Delta.\mathbf{Void}$ 
through given substitutions : 
\[
\Delta.\mathbf{Void} \vdash \mathbf{absurd}(b)[\mathbf{p}][\gamma.\mathbf{Void}] : A[\gamma.\mathbf{Void}]
\]
Now we can use that $\eta$-rule. 
\[
\inferrule
{
    \Delta \vdash b[\gamma] : \mathbf{Void} \quad \Delta.\mathbf{Void} \vdash \mathbf{absurd}(b)[\mathbf{p}][\gamma.\mathbf{Void}] : A[\gamma.\mathbf{Void}]
}
{
    \Delta \vdash \mathbf{absurd}(b[\gamma]) = \mathbf{absurd}(b)[\mathbf{p}][\gamma.\mathbf{Void}][\mathbf{id}.b[\gamma]] : A[\gamma.\mathbf{Void}][\mathbf{id}.b[\gamma]]
}
\tag{*}
\]
However here, 
\[\mathbf{p} \circ \gamma.\mathbf{Void} \circ (\mathbf{id}.b[\gamma]) = \mathbf{p} \circ \gamma.b[\gamma] = \gamma\]
and 
\[\gamma.\mathbf{Void} \circ \mathbf{id}.b[\gamma] = \gamma.b[\gamma] \]
We can clean up the result of (*) as : 
\[\Delta \vdash \mathbf{absurd}(b[\gamma]) = \mathbf{absurd}(b)[\gamma] : A[\gamma.b[\gamma]]\]
This is end of proof. 
\end{proof}
\end{tcolorbox}

Here, I can construct further realize about this type. As programmer's perspective, 
we can't reach $\Gamma.\mathbf{Void}$ context during the run-time. So one function of \textbf{Void} is that, 
represent the unreachable branch (or pattern matching). The another one is, representing negation. 
For $\neg A$, we can construct type $A \rightarrow \mathbf{Void}$. This means that, 
if we have both term of $A$ type and $A \rightarrow \mathbf{Void}$, then such context is wrong. 

\newpage 

\section{Booleans}

Almost type system contains Boolean type, which is characterized by 2 elements : true and false. 
However, we've already talk about true and false. It was \textbf{Unit} and \textbf{Void} type. 
Here are somewhat differences between such true, false and boolean's true and false. 
With \textbf{tt}, we can always prove \lq true' in any context. With $\mathbf{absurd}(-)$, 
we can prove that current context is wrong. However, \textbf{false} term of type \textbf{Bool} does not means 
current context is wrong. \textbf{Bool} just give us \lq case analysis tool'. 
And with this 2-ary case analysis tool, we can generate n-ary case analysis tool. 
(if, else if, else if, ... , else) With general notion of Boolean type, the basic construction is straight-forward and not difficult. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.3.1.]\hypertarget{const 3.3.1.}{}
\begin{mathpar}
\inferrule
{ \vdash \Gamma \text{ cx}}
{
    \Gamma \vdash \mathbf{Bool} \text{ type}
}
\and  
\inferrule
{
    \Delta \vdash \gamma : \Gamma   
}
{
    \Delta \vdash \mathbf{Bool}[\gamma] = \mathbf{Bool} \text{ type}
}
\end{mathpar}
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.3.2.]\hypertarget{const 3.3.2.}{}
    \begin{mathpar}
    \inferrule
    { \vdash \Gamma \text{ cx}}
    {
        \Gamma \vdash \mathbf{true} : \mathbf{Bool}
    }
    \and  
    \inferrule
    { \vdash \Gamma \text{ cx}}
    {
        \Gamma \vdash \mathbf{false} : \mathbf{Bool}
    }
    \end{mathpar}
    \begin{mathpar}
    \inferrule
    {
        \Delta \vdash \gamma : \Gamma   
    }
    {
        \Delta \vdash \mathbf{true} = \mathbf{true}[\gamma] : \mathbf{Bool}
    }
    \and  
    \inferrule
    {
        \Delta \vdash \gamma : \Gamma   
    }
    {
        \Delta \vdash \mathbf{false} = \mathbf{false}[\gamma] : \mathbf{Bool}
    }
    \end{mathpar}
\end{tcolorbox}

However, does \textbf{Bool} actually have \lq only' 2 terms? More rigorous question is that, our 
isomorphism structures can be following? 
\[Tm(\Gamma, \mathbf{Bool}) \cong \{\star, \star'\} \quad \text{ ( THIS IS WRONG !! ) }\]
Can you imagine that why this is wrong? If we choice this isomorphism to construct, then every 
\textbf{Bool} terms in claim context $\Gamma$ must be determined by \textbf{true} or \textbf{false}. 
i.e. we must always have definitional equality that such claim of \textbf{Bool} type term and one of \textbf{true, false}. 
However, there are many un-deterministic possible boolean terms. For example, let $b : \mathbf{Bool}$ is true when Riemann Conjecture is true, otherwise false. 
If we choice above form for isomorphism, we must determine that $b$ is true or false. This is why we define \textbf{Bool} as inductive type. 
So as \textbf{Void}, we characterize \textbf{Bool} via mapping out property. 
Suppose following characterize target. 
\[Tm(\Gamma.\mathbf{Bool}, A) \cong \quad ?\]
If we have term $a \in Tm(\Gamma.\mathbf{Bool}, A)$, it works like \lq Lazy Evaluation of Boolean value $\mathbf{q}$.'
With respect to our intension of Boolean, there must be exactly 2 ways to \lq case analysis' or \lq Lazy Evaluate' such $\mathbf{q}$ both in $a$ and $A$. 
Just that is role of true and false. So our construction scheme now is \lq there are only 2 cases for interpret $\mathbf{q}$ in $Tm(\Gamma.\mathbf{Bool}, A)$. 
So one pull-back (evaluation) way for $a$ is $\Gamma \vdash a[\mathbf{id.true}] = A[\mathbf{id.true}]$ and another one is that $\Gamma \vdash a[\mathbf{id.false}] : A[\mathbf{id.false}]$. 
We can represent this scheme via following mathematical construction : 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 3.3.3.]\hypertarget{const 3.3.3.}{}
    \[\mathbf{Bool}_\Gamma \in Ty(\Gamma)\]
    \[\mathbf{true}_\Gamma, \mathbf{false}_\Gamma \in Tm(\Gamma, \mathbf{Bool})\]
    \[((\mathbf{id.true})^*, (\mathbf{id.false})^*) : Tm(\Gamma.\mathbf{Bool}, A) \cong Tm(\Gamma, A[\mathbf{id.true}]) \times Tm(\Gamma, A[\mathbf{id.false}])\]
\end{tcolorbox}

This isomorphism structure immediately give us that we have only 2 way to evaluating $\mathbf{q}$ symbols in $Tm(\Gamma.\mathbf{Bool}, A)$ into 
previous context $\Gamma$. Understanding this story-line is quite important. 
This also means that, when we consider inductive type's term natural isomorphism, it works like \lq Lazy Evaluation' of symbol $\mathbf{q}$ and so, 
the way to pull-back (evaluate) it is defined via term-constructors for that inductive type. In this case, there was 2 term-constructor for each context, true and false. 

Now our job is that, unfold such isomorphism structures into our type system explicitly. 
For the forward map 
\[\iota : Tm(\Gamma.\mathbf{Bool}, A) \xrightarrow{\cong} Tm(\Gamma, A[\mathbf{id.true}]) \times Tm(\Gamma, A[\mathbf{id.false}])\]
Actually we do not need anything new. This direction just be written as : 
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma.\mathbf{Bool} \vdash a : A 
}
{
    \Gamma \vdash a[\mathbf{id.true}] : A[\mathbf{id.true}]
}
\quad 
\text{ and vice versa }
\]
This is already derivable with term-constructing rules. Important one is reverse map. 
\[\iota^{-1} : Tm(\Gamma, A[\mathbf{id.true}]) \times Tm(\Gamma, A[\mathbf{id.false}]) \xrightarrow{\cong} Tm(\Gamma.\mathbf{Bool}, A)\]
\\
Here, this has very important intuitive meaning. We'll give 2 terms exists in context $\Gamma$ each type is 
$A[\mathbf{id.true}]$ and $A[\mathbf{id.false}]$. Then, our target term is in $\Gamma.\mathbf{Bool}$ with 
lazy-evaluate target $\mathbf{q}$ is also ghostly given from $\Gamma$, if such $\mathbf{q}$ is true then evaluated as first one, 
if false, then second one. As I wrote above, the main intuition of this direction is \lq dependent if' type. 
\textbf{ Note that, to agree with our usage of if syntax, we'll built-in cut rule here. This will be explained in Exercise of this section. } 

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=green!75!black,title=Construction 3.3.4.]\hypertarget{const 3.3.4.}{}
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id.true}] \quad \Gamma \vdash a_f : A[\mathbf{id.false}] \quad \Gamma \vdash b : \mathbf{Bool}
}
{
    \Gamma \vdash \mathbf{if}(a_t, a_f, b) : A[\mathbf{id}.b]
}
\]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \\
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id.true}] \quad \Gamma \vdash a_f : A[\mathbf{id.false}] \quad \Gamma \vdash b : \mathbf{Bool}
}
{
    \Delta \vdash \mathbf{if}(a_t, a_f, b)[\gamma] = \mathbf{if}(a_t[\gamma], a_f[\gamma], b[\gamma]) : A[\gamma.b[\gamma]]
}
\]   
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id.true}] \quad \Gamma \vdash a_f : A[\mathbf{id.false}]
}
{
    \Gamma \vdash \mathbf{if}(a_t, a_f, \mathbf{true}) = a_t : A[\mathbf{id.true}] \quad \Gamma \vdash \mathbf{if}(a_t, a_f, \mathbf{false}) = a_f : A[\mathbf{id.false}]
}
\]
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma.\mathbf{Bool} \vdash a : A \quad \Gamma \vdash b : \mathbf{Bool} 
}
{
    \Gamma \vdash \mathbf{if}(a[\mathbf{id.true}], a[\mathbf{id.false}], b) = a[\mathbf{id}.b] : A[\mathbf{id}.b]
}
\tag{*}
\]
We'll see (*) in post section again. 
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 3.3.5.]\hypertarget{const 3.3.5.}{}

\textbf{Exercise 2.29.} Give rules axiomatizing the boolean analogue of $\mathbf{absurd}'$, and prove 
that these rules are interderivable with our rules for $\mathbf{if}(a_t, a_f, b)$. 

\begin{proof}
    
This is also question about \lq cut-rule applied' version of our backward homomorphism $\iota^{-1}$. 
Since 
\[\iota^{-1} : Tm(\Gamma, A[\mathbf{id}.\mathbf{true}]) \times Tm(\Gamma, A[\mathbf{id}.\mathbf{false}]) \rightarrow Tm(\Gamma.\mathbf{Bool}, A) \]
\\
Then when we directly construct this homomorphism, it will be 
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id}.\mathbf{true}] \quad \Gamma \vdash a_f : A[\mathbf{id}.\mathbf{false}]
}
{
    \Gamma.\mathbf{Bool} \vdash \mathbf{if}'(a_t, a_f) : A 
}
\]
\\
With above definition, the remaining modified rules are simply constructed : 
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma.\mathbf{Bool} : A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id}.\mathbf{true}] \quad \Gamma \vdash a_f : A[\mathbf{id}.\mathbf{false}]
}
{
    \Delta.\mathbf{Bool} \vdash \mathbf{if}'(a_t, a_f)[\gamma.\mathbf{Bool}] = \mathbf{if}'(a_t[\gamma], a_f[\gamma]) : A[\gamma.\mathbf{Bool}]
}
\]
\\
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id}.\mathbf{true}] \quad \Gamma \vdash a_f : A[\mathbf{id}.\mathbf{false}]
}
{
    \Gamma \vdash \mathbf{if}'(a_t, a_f)[\mathbf{id}.\mathbf{true}] = a_t : A[\mathbf{id}.\mathbf{true}]
}
\]
\\
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id}.\mathbf{true}] \quad \Gamma \vdash a_f : A[\mathbf{id}.\mathbf{false}]
}
{
    \Gamma \vdash \mathbf{if}'(a_t, a_f)[\mathbf{id}.\mathbf{false}] = a_f : A[\mathbf{id}.\mathbf{false}]
}
\]
\\
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma.\mathbf{Bool} \vdash a : A
}
{
    \Gamma.\mathbf{Bool} \vdash \mathbf{if}'(a[\mathbf{id}.\mathbf{true}], a[\mathbf{id}.\mathbf{false}]) = a : A}
\]
\\
However, our rules for $\mathbf{if}$ is constructed on context $\Gamma$. Actually, 
as same we discussed, it can be imagined as pull-backed $\mathbf{if}'$ into $\Gamma$. Here, we can write 
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id}.\mathbf{true}] \quad \Gamma \vdash a_f : A[\mathbf{id}.\mathbf{false}] \quad \Gamma \vdash b : \mathbf{Bool}
}
{
    \Gamma \vdash \mathbf{if}'(a_t, a_f)[\mathbf{id}.b] := \mathbf{if}(a_t, a_f, b) : A[\mathbf{id}.b]
}
\]
\\
Now, let's prove our original rules for $\mathbf{if}$ implies above $\beta, \eta$-rules. ( Here, I'll omit some premises when they are clear )
We have 
\[\Gamma \vdash \mathbf{if}(a_t, a_f, \mathbf{true}) = a_t : A[{\mathbf{id.true}}]\]
Rewrite this : 
\[\Gamma \vdash \mathbf{if'}(a_t, a_f)[\mathbf{id.true}] = a_t : A[\mathbf{id.true}]\]
Similarly, 
\[\Gamma \vdash \mathbf{if'}(a_t, a_f)[\mathbf{id.false}] = a_f : A[\mathbf{id.false}]\]
\\
This directly proves above $\beta$-rules. For $\eta$-rule, we can imagine following diagram : 

\[
\begin{tikzcd}
    \Gamma & \Gamma.\mathbf{Bool} \arrow[l, "p"]  \arrow[shift left, r, "id.q"] &  \Gamma.\mathbf{Bool.Bool} \arrow[l, "p.\mathbf{Bool}"]
\end{tikzcd}
\]

How can we use above intuition? Let's see. The original $\eta$-rule was 
\[
\inferrule
{\Gamma.\mathbf{Bool} \vdash A \text{ type} \quad \Gamma.\mathbf{Bool} \vdash a : A \quad \Gamma \vdash b : \mathbf{Bool} }
{ \Gamma \vdash \mathbf{if}(a[\mathbf{id.true}], a[\mathbf{id.false}], b) = a[\mathbf{id}.b] : A[\mathbf{id}.b]}
\]
\\
To prove the $\eta$-rule for $\mathbf{if'}$ of us, we'll use that 
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma.\mathbf{Bool} : A \text{ type} \quad \Gamma \vdash a_t : A[\mathbf{id}.\mathbf{true}] \quad \Gamma \vdash a_f : A[\mathbf{id}.\mathbf{false}]
}
{
    \Delta.\mathbf{Bool} \vdash \mathbf{if}'(a_t, a_f)[\gamma.\mathbf{Bool}] = \mathbf{if}'(a_t[\gamma], a_f[\gamma]) : A[\gamma.\mathbf{Bool}]
}
\]
\\
We can write this as 
\[
\inferrule
{
    \Gamma.\mathbf{Bool} \vdash \mathbf{p} : \Gamma \quad \Gamma.\mathbf{Bool} \vdash a : A \quad \Gamma \vdash a[\mathbf{id.true}] : A[\mathbf{id.true}] \quad \Gamma \vdash a[\mathbf{id.false}] : A[\mathbf{id.false}]
}
{
    \Gamma.\mathbf{Bool}.\mathbf{Bool} \vdash \mathbf{if'}(a[\mathbf{id.true}], a[\mathbf{id.false}])[\mathbf{p.Bool}] = \mathbf{if'}(a[\mathbf{id.true}][\mathbf{p}], a[\mathbf{id.false}][\mathbf{p}]) : A[\mathbf{p.Bool}]
}
\]
We can pull-back the result using $\Gamma.\mathbf{Bool} \vdash \mathbf{q} : \mathbf{Bool}$. 
\[\Gamma.\mathbf{Bool} \vdash \mathbf{if'}(a[\mathbf{id.true}], a[\mathbf{id.false}])[\mathbf{p.Bool}][\mathbf{id.q}] \] \[= \mathbf{if'}(a[\mathbf{id.true}][\mathbf{p}], a[\mathbf{id.false}][\mathbf{p}])[\mathbf{id.q}] : A[\mathbf{p.Bool}][\mathbf{id.q}]\]
\\
Rewrite this as 
\[
\Gamma.\mathbf{Bool} \vdash \mathbf{if'}(a[\mathbf{id.true}], a[\mathbf{id.false}]) = \mathbf{if}(a[\mathbf{id.true}][\mathbf{p}], a[\mathbf{id.false}][\mathbf{p}], \mathbf{q}) : A 
\]
\\
However, we already know that $\mathbf{id.true} \circ \mathbf{p} = \mathbf{p}.A \circ \mathbf{id.true'}$ where $\mathbf{id.true}$ is arrow $\Gamma.\mathbf{Bool} \rightarrow \Gamma.\mathbf{Bool.Bool}$. Then ,  
\[
\Gamma.\mathbf{Bool} \vdash \mathbf{if'}(a[\mathbf{id.true}], a[\mathbf{id.false}]) = \mathbf{if}(a[\mathbf{p}.A][\mathbf{id.true'}], a[\mathbf{p}.A][\mathbf{id.false'}], \mathbf{q}) : A 
\]
However, the $\eta$-rule of given $\mathbf{if}$ on $\Gamma.\mathbf{Bool}$ context implies that 
\[\mathbf{if'}(a[\mathbf{id.true}], a[\mathbf{id.false}]) = \mathbf{if}(a[\mathbf{p}.A][\mathbf{id.true'}], a[\mathbf{p}.A][\mathbf{id.false'}], \mathbf{q}) = a[\mathbf{p.A}][\mathbf{id.q}] : A\]
Then finally, we can holds 
\[\Gamma.\mathbf{Bool} \vdash \mathbf{if'}(a[\mathbf{id.true}], a[\mathbf{id.false}]) = a : A\]
This is proof of $\eta$-rule for $\mathbf{if'}$. 
\end{proof}

\end{tcolorbox}


\newpage 
.
\end{document}