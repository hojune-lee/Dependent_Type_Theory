
\documentclass[12pt, a4paper, openany, twoside]{book}
\usepackage[left=1in,right=1in,bottom=0.5in,top=0.8in]{geometry}
\usepackage{amsfonts}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{epstopdf}
\usepackage[pdfpagelabels,hyperindex]{hyperref}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{float}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{longtable}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[most]{tcolorbox}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz-cd}
\usepackage{comment}
\usepackage{mathpartir}

\linespread{1.2} 

\hypersetup{
pdftitle={.},
pdfauthor={Hojune Lee},
}

\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\DeclareRobustCommand{\stirling}{\genfrac\{\}{0pt}{}}
\newtheorem{thm}{Theorem}[subsection]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{quest}[thm]{Question}
\newtheorem{ppty}[thm]{Property}
\newtheorem{ppties}[thm]{Properties}
\newtheorem{axiom}[thm]{Axiom}
\newtheorem{claim}[thm]{Claim}
\newtheorem{prob}[thm]{Problem}


\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{defns}[thm]{Definitions}
\newtheorem{con}[thm]{Construction}
\newtheorem{exmp}[thm]{Example}
\newtheorem{exmps}[thm]{Examples}
\newtheorem{notn}[thm]{Notation}
\newtheorem{notns}[thm]{Notations}
\newtheorem{addm}[thm]{Addendum}
\newtheorem{exer}[thm]{Exercise}
\newtheorem{limit}[thm]{Limitation}


\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\newtheorem{rems}[thm]{Remarks}
\newtheorem{warn}[thm]{Warning}
\newtheorem{sch}[thm]{Scholium}
\newenvironment{thmbox}[1][]{\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title={#1}]}{\end{tcolorbox}}


% newcommand bb
    \newcommand{\BA}{{\mathbb {A}}} \newcommand{\BB}{{\mathbb {B}}}
    \newcommand{\BC}{{\mathbb {C}}} \newcommand{\BD}{{\mathbb {D}}}
    \newcommand{\BE}{{\mathbb {E}}} \newcommand{\BF}{{\mathbb {F}}}
    \newcommand{\BG}{{\mathbb {G}}} \newcommand{\BH}{{\mathbb {H}}}
    \newcommand{\BI}{{\mathbb {I}}} \newcommand{\BJ}{{\mathbb {J}}}
    \newcommand{\BK}{{\mathbb {U}}} \newcommand{\BL}{{\mathbb {L}}}
    \newcommand{\BM}{{\mathbb {M}}} \newcommand{\BN}{{\mathbb {N}}}
    \newcommand{\BO}{{\mathbb {O}}} \newcommand{\BP}{{\mathbb {P}}}
    \newcommand{\BQ}{{\mathbb {Q}}} \newcommand{\BR}{{\mathbb {R}}}
    \newcommand{\BS}{{\mathbb {S}}} \newcommand{\BT}{{\mathbb {T}}}
    \newcommand{\BU}{{\mathbb {U}}} \newcommand{\BV}{{\mathbb {V}}}
    \newcommand{\BW}{{\mathbb {W}}} \newcommand{\BX}{{\mathbb {X}}}
    \newcommand{\BY}{{\mathbb {Y}}} \newcommand{\BZ}{{\mathbb {Z}}}

% newcommand  scr
    \newcommand{\sA}{{\mathscr {A}}} \newcommand{\sB}{{\mathscr {B}}}
    \newcommand{\sC}{{\mathscr {C}}} \newcommand{\sD}{{\mathscr {D}}}
    \newcommand{\sE}{{\mathscr {E}}} \newcommand{\sF}{{\mathscr {F}}}
    \newcommand{\sG}{{\mathscr {G}}} \newcommand{\sH}{{\mathscr {H}}}
    \newcommand{\sI}{{\mathscr {I}}} \newcommand{\sJ}{{\mathscr {J}}}
    \newcommand{\sK}{{\mathscr {K}}} \newcommand{\sL}{{\mathscr {L}}}
    \newcommand{\sN}{{\mathscr {N}}} \newcommand{\sM}{{\mathscr {M}}}
    \newcommand{\sO}{{\mathscr {O}}} \newcommand{\sP}{{\mathscr {P}}}
    \newcommand{\sQ}{{\mathscr {Q}}} \newcommand{\sR}{{\mathscr {R}}}
    \newcommand{\sS}{{\mathscr {S}}} \newcommand{\sT}{{\mathscr {T}}}
    \newcommand{\sU}{{\mathscr {U}}} \newcommand{\sV}{{\mathscr {V}}}
    \newcommand{\sW}{{\mathscr {W}}} \newcommand{\sX}{{\mathscr {X}}}
    \newcommand{\sY}{{\mathscr {Y}}} \newcommand{\sZ}{{\mathscr {Z}}}


% newcommand cal
    \newcommand{\CA}{{\mathcal {A}}} \newcommand{\CB}{{\mathcal {B}}}
    \newcommand{\CC}{{\mathcal {C}}} \newcommand{\CD}{{\mathcal {D}}}
    \newcommand{\CE}{{\mathcal {E}}} \newcommand{\CF}{{\mathcal {F}}}
    \newcommand{\CG}{{\mathcal {G}}} \newcommand{\CH}{{\mathcal {H}}}
    \newcommand{\CI}{{\mathcal {I}}} \newcommand{\CJ}{{\mathcal {J}}}
    \newcommand{\CK}{{\mathcal {K}}} \newcommand{\CL}{{\mathcal {L}}}
    \newcommand{\CM}{{\mathcal {M}}} \newcommand{\CN}{{\mathcal {N}}}
    \newcommand{\CO}{{\mathcal {O}}} \newcommand{\CP}{{\mathcal {P}}}
    \newcommand{\CQ}{{\mathcal {Q}}} \newcommand{\CR}{{\mathcal {R}}}
    \newcommand{\CS}{{\mathcal {S}}} \newcommand{\CT}{{\mathcal {T}}}
    \newcommand{\CU}{{\mathcal {U}}} \newcommand{\CV}{{\mathcal {V}}}
    \newcommand{\CW}{{\mathcal {W}}} \newcommand{\CX}{{\mathcal {X}}}
    \newcommand{\CY}{{\mathcal {Y}}} \newcommand{\CZ}{{\mathcal {Z}}}

    % newcommand frak
     \newcommand{\fa}{{\mathfrak{a}}}  \newcommand{\fb}{{\mathfrak{b}}}
     \newcommand{\fc}{{\mathfrak{c}}}  \newcommand{\fd}{{\mathfrak{d}}}
     \newcommand{\fe}{{\mathfrak{e}}}  \newcommand{\ff}{{\mathfrak{f}}}
     \newcommand{\fg}{{\mathfrak{g}}}  \newcommand{\fh}{{\mathfrak{h}}}
     \newcommand{\fii}{{\mathfrak{i}}}  \newcommand{\fj}{{\mathfrak{j}}}
     \newcommand{\fk}{{\mathfrak{m}}}  \newcommand{\fl}{{\mathfrak{l}}}
     \newcommand{\fm}{{\mathfrak{m}}}  \newcommand{\fn}{{\mathfrak{n}}}
     \newcommand{\fo}{{\mathfrak{o}}}  \newcommand{\fp}{{\mathfrak{p}}}
     \newcommand{\fq}{{\mathfrak{q}}}  \newcommand{\fr}{{\mathfrak{r}}}
     \newcommand{\fs}{{\mathfrak{s}}}  \newcommand{\ft}{{\mathfrak{t}}}
     \newcommand{\fu}{{\mathfrak{u}}}  \newcommand{\fv}{{\mathfrak{v}}}
     \newcommand{\fw}{{\mathfrak{w}}}  \newcommand{\fx}{{\mathfrak{x}}}
     \newcommand{\fy}{{\mathfrak{y}}}  \newcommand{\fz}{{\mathfrak{z}}}

    \newcommand{\fA}{{\mathfrak{A}}}  \newcommand{\fB}{{\mathfrak{B}}}
     \newcommand{\fC}{{\mathfrak{C}}}  \newcommand{\fD}{{\mathfrak{D}}}
     \newcommand{\fE}{{\mathfrak{E}}}  \newcommand{\fF}{{\mathfrak{F}}}
     \newcommand{\fG}{{\mathfrak{G}}}  \newcommand{\fH}{{\mathfrak{H}}}
     \newcommand{\fI}{{\mathfrak{I}}}  \newcommand{\fJ}{{\mathfrak{J}}}
     \newcommand{\fK}{{\mathfrak{K}}}  \newcommand{\fL}{{\mathfrak{L}}}
     \newcommand{\fM}{{\mathfrak{M}}}  \newcommand{\fN}{{\mathfrak{N}}}
     \newcommand{\fO}{{\mathfrak{O}}}  \newcommand{\fP}{{\mathfrak{P}}}
     \newcommand{\fQ}{{\mathfrak{Q}}}  \newcommand{\fR}{{\mathfrak{R}}}
     \newcommand{\fS}{{\mathfrak{S}}}  \newcommand{\fT}{{\mathfrak{T}}}
     \newcommand{\fU}{{\mathfrak{U}}}  \newcommand{\fV}{{\mathfrak{V}}}
     \newcommand{\fW}{{\mathfrak{W}}}  \newcommand{\fX}{{\mathfrak{X}}}
     \newcommand{\fY}{{\mathfrak{Y}}}  \newcommand{\fZ}{{\mathfrak{Z}}}



 % newcommand :rm
     \newcommand{\RA}{{\mathrm {A}}} \newcommand{\RB}{{\mathrm {B}}}
    \newcommand{\RC}{{\mathrm {C}}} \newcommand{\RD}{{\mathrm {D}}}
    \newcommand{\RE}{{\mathrm {E}}} \newcommand{\RF}{{\mathrm {F}}}
    \newcommand{\RG}{{\mathrm {G}}} \newcommand{\RH}{{\mathrm {H}}}
    \newcommand{\RI}{{\mathrm {I}}} \newcommand{\RJ}{{\mathrm {J}}}
    \newcommand{\RK}{{\mathrm {K}}} \newcommand{\RL}{{\mathrm {L}}}
    \newcommand{\RM}{{\mathrm {M}}} \newcommand{\RN}{{\mathrm {N}}}
    \newcommand{\RO}{{\mathrm {O}}} \newcommand{\RP}{{\mathrm {P}}}
    \newcommand{\RQ}{{\mathrm {Q}}} \newcommand{\RR}{{\mathrm {R}}}
    \newcommand{\RS}{{\mathrm {S}}} \newcommand{\RT}{{\mathrm {T}}}
    \newcommand{\RU}{{\mathrm {U}}} \newcommand{\RV}{{\mathrm {V}}}
    \newcommand{\RW}{{\mathrm {W}}} \newcommand{\RX}{{\mathrm {X}}}
    \newcommand{\RY}{{\mathrm {Y}}} \newcommand{\RZ}{{\mathrm {Z}}}

    \newcommand{\Ad}{{\mathrm{Ad}}} \newcommand{\Aut}{{\mathrm{Aut}}}
    \newcommand{\Br}{{\mathrm{Br}}} \newcommand{\Ch}{{\mathrm{Ch}}}
    \newcommand{\cod}{{\mathrm{cod}}} \newcommand{\cont}{{\mathrm{cont}}}
    \newcommand{\cl}{{\mathrm{cl}}}   \newcommand{\Cl}{{\mathrm{Cl}}}
    \newcommand{\disc}{{\mathrm{disc}}}\newcommand{\Eis}{{\mathrm{Eis}}}
    \newcommand{\Div}{{\mathrm{Div}}} \renewcommand{\div}{{\mathrm{div}}}
    \newcommand{\End}{{\mathrm{End}}} \newcommand{\Frob}{{\mathrm{Frob}}}
    \newcommand{\Gal}{{\mathrm{Gal}}} \newcommand{\GL}{{\mathrm{GL}}}
    \newcommand{\Hom}{{\mathrm{Hom}}} \renewcommand{\Im}{{\mathrm{Im}}}
    \newcommand{\Ind}{{\mathrm{Ind}}} \newcommand{\ind}{{\mathrm{ind}}}
    \newcommand{\inv}{{\mathrm{inv}}}
    \newcommand{\Isom}{{\mathrm{Isom}}} \newcommand{\Jac}{{\mathrm{Jac}}}
    \newcommand{\ad}{{\mathrm{ad}}}  \newcommand{\Tr}{{\mathrm{Tr}}}
    \newcommand{\Ker}{{\mathrm{Ker}}} \newcommand{\Ros}{{\mathrm{Ros}}}
    \newcommand{\Lie}{{\mathrm{Lie}}} \newcommand{\Hol}{{\mathrm{Hol}}}

    \newcommand{\cyc}{{\mathrm{cyc}}}\newcommand{\id}{{\mathrm{id}}}
    \newcommand{\new}{{\mathrm{new}}} \newcommand{\NS}{{\mathrm{NS}}}
    \newcommand{\ord}{{\mathrm{ord}}} \newcommand{\rank}{{\mathrm{rank}}}
    \newcommand{\PGL}{{\mathrm{PGL}}} \newcommand{\Pic}{\mathrm{Pic}}
    \newcommand{\cond}{\mathrm{cond}} \newcommand{\Is}{{\mathrm{Is}}}
    \renewcommand{\Re}{{\mathrm{Re}}} \newcommand{\reg}{{\mathrm{reg}}}
    \newcommand{\Res}{{\mathrm{Res}}} \newcommand{\Sel}{{\mathrm{Sel}}}
    \newcommand{\RTr}{{\mathrm{Tr}}} \newcommand{\alg}{{\mathrm{alg}}}
    \newcommand{\PSL}{{\mathrm{PSL}}}

\newcommand{\coker}{{\mathrm{coker}}}
\newcommand{\val}{{\mathrm{val}}} \newcommand{\sign}{{\mathrm{sign}}}
\newcommand{\mult}{{\mathrm{mult}}} \newcommand{\Vol}{{\mathrm{Vol}}}
\newcommand{\Meas}{{\mathrm{Meas}}}\renewcommand{\mod}{\ \mathrm{mod}\ }
\newcommand{\Ann}{\mathrm{Ann}}
\newcommand{\Tor}{\mathrm{Tor}}
\newcommand{\Supp}{\mathrm{Supp}}\newcommand{\supp}{\mathrm{supp}}
\newcommand{\Max}{\mathrm{Max}}
\newcommand{\Coker}{\mathrm{Coker}}
\newcommand{\Stab}{\mathrm{Stab}}
\newcommand{\Irr}{\mathrm{Irr}}\newcommand{\Inf}{\mathrm{Inf}}\newcommand{\Sup}{\mathrm{Sup}}
\newcommand{\rk}{\mathrm{rk}}\newcommand{\Fil}{\mathrm{Fil}}
\newcommand{\Sim}{{\mathrm{Sim}}} \newcommand{\SL}{{\mathrm{SL}}}
\newcommand{\Spec}{{\mathrm{Spec}}} \newcommand{\SO}{{\mathrm{SO}}}
\newcommand{\SU}{{\mathrm{SU}}} \newcommand{\Sym}{{\mathrm{Sym}}}
\newcommand{\sgn}{{\mathrm{sgn}}} \newcommand{\tr}{{\mathrm{tr}}}
\newcommand{\tor}{{\mathrm{tor}}}  \newcommand{\ur}{{\mathrm{ur}}}
\newcommand{\vol}{{\mathrm{vol}}}  \newcommand{\ab}{{\mathrm{ab}}}
\newcommand{\Sh}{{\mathrm{Sh}}} \newcommand{\Ell}{{\mathrm{Ell}}}
\newcommand{\Char}{{\mathrm{Char}}}\newcommand{\Tate}{{\mathrm{Tate}}}
\newcommand{\corank}{{\mathrm{corank}}} \newcommand{\Cond}{{\mathrm{Cond}}}
\newcommand{\Inn}{{\mathrm{Inn}}} \newcommand{\Spf}{{\mathrm{Spf}}}
\newcommand{\Mat}{{\mathrm{Mat}}}


    \font\cyr=wncyr10  \newcommand{\Sha}{\hbox{\cyr X}}
    \newcommand{\wt}{\widetilde} \newcommand{\wh}{\widehat} \newcommand{\ck}{\check}
    \newcommand{\pp}{\frac{\partial\bar\partial}{\pi i}}
    \newcommand{\pair}[1]{\langle {#1} \rangle}
    \newcommand{\wpair}[1]{\left\{{#1}\right\}}
    \newcommand{\intn}[1]{\left( {#1} \right)}
    \newcommand{\norm}[1]{\|{#1}\|}
    \newcommand{\sfrac}[2]{\left( \frac {#1}{#2}\right)}
    \newcommand{\ds}{\displaystyle}
    \newcommand{\ov}{\overline}
    \newcommand{\Gros}{Gr\"{o}ssencharaktere}
    \newcommand{\incl}{\hookrightarrow}
    \newcommand{\lra}{\longrightarrow}
     \newcommand{\ra}{\rightarrow}
    \newcommand{\imp}{\Longrightarrow}
    \newcommand{\lto}{\longmapsto}
    \newcommand{\bs}{\backslash}
    \newcommand{\nequiv}{\equiv\hspace{-7.8pt}/}
    \theoremstyle{plain}


\definecolor{energy}{RGB}{114,0,172}
\definecolor{freq}{RGB}{45,177,93}
\definecolor{spin}{RGB}{251,0,29}
\definecolor{signal}{RGB}{203,23,206}
\definecolor{circle}{RGB}{217,86,16}
\definecolor{average}{RGB}{203,23,206}
\newcommand{\K}{\operatornamewithlimits{K}}
\colorlet{shadecolor}{gray!20}
\pgfplotsset{compat=1.9}
\def\N{10}
\def\M{4}
\usepgflibrary{fpu}


\def\upint{\mathchoice%
    {\mkern13mu\overline{\vphantom{\intop}\mkern7mu}\mkern-20mu}%
    {\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
    {\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
    {\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
  \int}
\def\lowint{\mkern3mu\underline{\vphantom{\intop}\mkern7mu}\mkern-10mu\int}



\makeatletter
\let\c@equation\c@thm
\raggedbottom
\makeatother
\numberwithin{equation}{section}
%--------Meta Data: Fill in your info------
\author{Hojune Lee, 20210541}

\title{Dependent Type Theory}
\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{9cm}
            
        \Huge
        \textbf{Dependent Type Theory}
    
        \vspace{1cm}
        \large
        About Extensional Type Systems
        \vspace{3cm}
        
        \LARGE
        \textbf{Hojune Lee}
            
        \vspace{8cm}
            
        \normalsize
        \textbf{School of Computing, KAIST}\\  
    \end{center}
\end{titlepage}

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}

\newpage 

\chapter{Context and Substitutions}

\section{Intuitions}

In simple type theory, every thing was quite clear. This is because that, if we once fix the rules for types in simple type theory, 
then all possible types are determined immediately by inductive way. We can informally think this as \lq propositional logic'-like type construction. 
However, many things are different in dependent type system. Let's think dependent type system as \lq first order logic'-like type construction. 
Imagine the formulas in first order logic as types in dependent type theory. 
I hope that this is proper intuitive thinking for the main differences between two type systems. \\

Once we imagine FOL formula-style type, it means that each type can contain variables and constants as it's representation. 
It means that for each variables which are appeared in type representation, we must know what are the types of each variables.
That is Context's role. \\

Now, we need to construct the intuition for contexts and substitutions. Contexts are \lq wolrds' of terms and types. 
And substitutions are \lq traffic way' between each worlds( contexts ). Then naturally, following questions are arising. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Questions]
    \begin{enumerate}
        \item Is this world ( Context ) well-formed ?
        \item In this world ( Context ) $\Gamma$, what terms of type $A$ are well-formed ? 
        \item In this world ( Context ) $\Gamma$, what types are well-formed ? 
        \item Between 2 worlds ( Context ) $\Delta$ and $\Gamma$, is traffic way ( substitution ) $\gamma$ well-formed ?
        \item In this world ( Context ), which terms/types/substitutions are equivalent? 
    \end{enumerate}
\end{tcolorbox}

Actually, this is all about \lq judgement rules' referred in Notation 2.3.1. of textbook. 
Formally, we can write format for above judgements. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Formal Representations for Judgements]
    \begin{enumerate}
        \item $\vdash \Gamma \text{ cx}$
        \item $\Gamma \vdash a : A$
        \item $\Gamma \vdash A \text{ type}$
        \item $\Delta \vdash \gamma : \Gamma$
        \item $\Gamma \vdash a = a' : A, \quad \Gamma \vdash A = A' \text{ type}, \quad \Delta \vdash \gamma = \gamma' : \Gamma$ 
    \end{enumerate}
\end{tcolorbox}

In this chapter, we'll discuss the rules for above judgements. 
Now, it's time to define explicit judgement rules that we referred. 
\newpage
\section{Contexts Judgements}
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.2.1.]\label{cx judgement}
    \begin{mathpar}
    \inferrule
    { }
    {\vdash \mathbf{1} \text{ cx}}
    \and   
    \inferrule
    {\vdash \Gamma \text{ cx} \quad \Gamma \vdash A \text{ type}}
    {\vdash \Gamma.A \text{ cx}}
    \end{mathpar}
\end{tcolorbox}
Here, $\mathbf{1}$ is empty context and each context is just list of types. (No variable names) It means that 
we use De Bruijn index, i.e. in each context, index automatically determines the variable in context. 

\section{Substitution Judgements}\label{subst judgement} \quad \\

However, before that the most 
important one is understanding direction of traffic way (from now on, substitution). 

\begin{tcolorbox}[colback=yellow!10!white,colframe=blue!75!black,title=Definition 1.3.1.]\label{1.3.1}
    If $\Delta \vdash \gamma : \Gamma$, then $\gamma$ is substitution from $\Delta$ to $\Gamma$. i.e. 
    \[\gamma : \Delta \rightarrow \Gamma\]
    However, it's role is send types and terms of $\Gamma$ into $\Delta$. (Note : Direction is important)
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=1.3.  Intuitions for direction of substitutions]\label{intuition}
    To understand why here use this notation, see following example. Imagine that contexts are \lq sets' 
    and substitutions are function between them. There are 2 sets $\Delta, \Gamma$ and mapping $\gamma : \Delta \rightarrow \Gamma$. 
    Suppose that there is a function $g : \Gamma \rightarrow \mathbb{R}$, which is defined on set $\Gamma$. How can we 
    \lq use' this function in $\Delta$ set? One way is that, 
    \[g : \Gamma \rightarrow \mathbb{R} \implies g \circ \gamma : \Delta \rightarrow \mathbb{R}\]
    Then we can \lq use' the function $g$ in domain $\Delta$. This exactly corresponds in our notation. 
    For $\Delta \vdash \gamma : \Gamma$, when we define $\gamma : \Delta \rightarrow \Gamma$, 
    \[\Gamma \vdash A \text{ type} \implies \Delta \vdash A[\gamma] \text{ type}\]
    Since $A$ is type in $\Gamma$ and the direction of substitution is $\gamma : \Delta \rightarrow \Gamma$, we say that 
    $A[\gamma]$ is pull-backed type of $A$ through $\gamma : \Delta \rightarrow \Gamma$. 
\end{tcolorbox}

First, as above we can easily define the application rule of substitution. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.2.]
    \begin{mathpar}
    \inferrule
    {\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type}}
    {\Delta \vdash A[\gamma] \text{ type}}
    \and   
    \inferrule
    {\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a : A}
    {\Delta \vdash a[\gamma] : A[\gamma]}
    \end{mathpar}
\end{tcolorbox}
These rules give us that we can immigrate(pull-back) terms and types of $\Gamma$ into $\Delta$. 
And now, in our setting each contexts are different \lq worlds'. So we need to introduce explicit \textbf{weakening rule}, which intuitively means that 
we can bring well-formed types and terms into $\Gamma$ into $\Gamma.A$, expanded context. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.3.]
    \begin{mathpar}
    \inferrule
    {\Gamma \vdash A \text{ type}}
    {\Gamma.A \vdash \mathbf{p} : \Gamma}
    \end{mathpar}
\end{tcolorbox}
In diagram, 
\[
\begin{tikzcd}
{\Gamma.A} \arrow[r, "p"] & {\Gamma} \\
\end{tikzcd}
\]
Means that, we can pull-back types $B$ and terms $t$ in world $\Gamma$ into $\Gamma.A$ by write $B[\mathbf{p}], t[\mathbf{p}]$
Moreover, we can introduce following rules. (Actually, following rules need because our context-substitution system become a category.) 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.4.]
    \begin{mathpar}
    \inferrule
    {\vdash \Gamma \text{ cx}}
    {\Gamma \vdash \mathbf{id} : \Gamma}
    \and   
    \inferrule
    {\Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0}
    {\Gamma_2 \vdash \gamma_0 \circ \gamma_1 : \Gamma_0}
    \end{mathpar}
\end{tcolorbox}
Second one can be conflict when we see first. However, let's draw the diagram. 
\[
\begin{tikzcd}
{\Gamma_2} \arrow[r, "\gamma_1"] \arrow[d, "\gamma_0 \circ \gamma_1"'] & {\Gamma_1} \arrow[ld, "\gamma_0"] &\\
{\Gamma_0} 
\end{tikzcd}\]
Then, above representation is very clear. It become same notation in our function calculus. Similarly, 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.5.]
    \begin{mathpar}
    \inferrule
    {\Delta \vdash \gamma : \Gamma}
    {\Delta \vdash \gamma \circ \mathbf{id} = \mathbf{id} \circ \gamma = \gamma : \Gamma}
    \and   
    \inferrule
    {\Gamma_3 \vdash \gamma_2 : \Gamma_2 \quad \Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0}
    {\Gamma_3 \vdash (\gamma_0 \circ \gamma_1) \circ \gamma_2 = \gamma_0 \circ (\gamma_1 \circ \gamma_2) : \Gamma_0}
    \end{mathpar}
\end{tcolorbox}
This two rules are also very clear when we see the diagram. 
\[
\begin{tikzcd}
{\Delta} \arrow[loop left, "id"] \arrow[r, "\gamma"] & {\Gamma} \arrow[loop right, "id"]
\end{tikzcd}
\]
\\
\[
\begin{tikzcd}[row sep = large, column sep = huge]
    {\Gamma_3} \arrow[r, "\gamma_2"]  \arrow[d, "(\gamma_0 \circ \gamma_1) \circ \gamma_2"'] & {\Gamma_2}\arrow[ld, "\gamma_0 \circ \gamma_1"] \arrow[d, "\gamma_1"] \\
    {\Gamma_0} & {\Gamma_1} \arrow[l, "\gamma_0"] 
\end{tikzcd}
\quad
\iff
\quad
\begin{tikzcd}[row sep = large, column sep = huge]
{\Gamma_3} \arrow[r, "\gamma_2"] \arrow[rd, "\gamma_1 \circ \gamma_2"] \arrow[d, "\gamma_0 \circ (\gamma_1 \circ \gamma_2)"'] & {\Gamma_2} \arrow[d, "\gamma_1"] \\
{\Gamma_0} & {\Gamma_1} \arrow[l, "\gamma_0"] 
\end{tikzcd}
\]
\\
Then we can imagine following equivalent rules clearly. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.6.]
\begin{mathpar}
\inferrule
{\Gamma \vdash A \text{ type}}
{\Gamma \vdash A[\mathbf{id}] = A \text{ type}}
\and   
\inferrule
{\Gamma \vdash a : A}
{\Gamma \vdash a[\mathbf{id}] = a : A}
\end{mathpar}
\\
\[
\inferrule
{\Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0 \quad \Gamma_0 \vdash A \text{ type}}
{\Gamma_2 \vdash A[\gamma_0 \circ \gamma_1] = A[\gamma_0][\gamma_1] \text{ type}}
\]
\\
\[
\inferrule
{\Gamma_2 \vdash \gamma_1 : \Gamma_1 \quad \Gamma_1 \vdash \gamma_0 : \Gamma_0 \quad \Gamma_0 \vdash a : A}
{\Gamma_2 \vdash a[\gamma_0 \circ \gamma_1] = a[\gamma_0][\gamma_1] : A[\gamma_0 \circ \gamma_1]}
\]
\end{tcolorbox}
These rules are very intuitable. When we draw diagram, 
\[
\begin{tikzcd}
    \Gamma_2 \arrow[d, "\gamma_0 \circ \gamma_1"'] \arrow[r, "\gamma_1"] & \Gamma_1 \arrow[ld, "\gamma_0"] \\
    \Gamma_0
\end{tikzcd}
\]
For example, look the last rule. $a$ is term in the world $\Gamma_0$. We want to 
bring this term into $\Gamma_2$. Bring means that, we want to use \lq function' $a$ in $\Gamma_2$. i.e. such term in $\Gamma_2$ is 
working same roles with $a$ in $\Gamma_0$. We've studied in box \ref{intuition}, there are 2 ways to bring $a$ from $\Gamma_0$ into $\Gamma_2$. 
\[
\begin{tikzcd}
    \Gamma_2 \arrow[d, "\gamma_0 \circ \gamma_1"', red] \arrow[r, "\gamma_1", blue] & \Gamma_1 \arrow[ld, "\gamma_0", blue] \\
    \Gamma_0
\end{tikzcd}
\]

One is pulling back via red way, and another one is via blue way. $a$ via red way is $a[\gamma_0 \circ \gamma_1]$ in $\Gamma_2$, 
and via blue way is $a[\gamma_0][\gamma_1]$ (Actually, $a[\gamma_0]$ is $a$ in $\Gamma_1$ wolrd. So we take it again into $\Gamma_2$.)
However, how can we use variable in well-formed context $\Gamma$ without own names? What is the meaning of De Bruijn index? Let's see how can we distinguish
variables in each \lq world' $\Gamma$. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.7.]\label{con 1.3.7.}
\[
\inferrule
{\Gamma \vdash A \text{ type}}
{\Gamma.A \vdash \mathbf{q} : A[\mathbf{p}]}
\]
\end{tcolorbox}
We can see context as a stack. $\mathbf{q}$ always means the top element of stack. 
However, stack $\Gamma.A$ contains type $A$ as top, which is type in $\Gamma$ wolrd. So 
the top variable's type in $\Gamma.A$ is $A[\mathbf{p}]$ which we take $A$ from $\Gamma$ into $\Gamma.A$. Similarly, we can 
access the any index of stack by following rule which is deribable from \ref{con 1.3.7.} 
\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Corolary 1.3.8.]
\[
\inferrule
{\Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B_1 \text{ type} \quad \cdots \Gamma.A.B_1.\cdots \vdash B_n \text{ type}}
{\Gamma.A.B_1.\cdots.B_n \vdash \mathbf{q}[\mathbf{p}^n] : A[\mathbf{p}^{n+1}]}
\]
\end{tcolorbox}
Now, it's time to discuss our main theme in this subsection \ref{subst judgement}.
Our ultimate goal is defining \lq valid traffic way from valid world to another valid world'. Let's discuss substitution 
judgement rules very intuitively. First, suppose that we only have rules for context judgements \ref{cx judgement}. 
The obvious thing that we must do first is, construct way from any $\Gamma$ into $\mathbf{1}$. The rules are simple. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.9.]
\begin{mathpar}
\inferrule
{\vdash \Gamma \text{ cx}}
{\Gamma \vdash ! : \mathbf{1}}
\and   
\inferrule
{\Gamma \vdash \delta : \mathbf{1}}
{\Gamma \vdash \delta = ! : \mathbf{1}}
\end{mathpar}
\end{tcolorbox}
\vspace{4mm}
What does it mean? It is 'way' from $\Gamma$ to $\mathbf{1}$. The role of this way is transfer terms and types in $\mathbf{1}$ into $\Gamma$ world. 
What terms and types are well-formed in $\mathbf{1}$? Just closed terms and types (No Variables). It is obviously 
terms and types in $\Gamma$ also. So we define the way is \lq unique' here. With this substitution, 
we can always transfer closed terms(e.g. 1, (1+1)) and closed types from $\mathbf{1}$ to any well-formed context $\Gamma$.  
Let's think this as a base case of our definition of traffic ways. Following construction determines how can we extends substitutions. 
\vspace{4mm}
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.10.]\hypertarget{subst extend}{}
\[\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta \vdash a : A[\gamma]}
{\Delta \vdash \gamma.a : \Gamma.A}\]
\end{tcolorbox}
Let's draw diagram. \\
\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]
\\
Is it clear? It means that, suppose that $\Gamma$ has $n$ variables ($x_1, \cdots, x_n$). Here we denote names for each variables for representation. 
And then, in this context $\Gamma$, $A$ is well-formed type. Then automatically $\Gamma.A$ is defined, where 
it has $n+1$ variables ($x_1, \cdots, x_n, x_{n+1}$). The key understanding is that, when we bring 
terms and types in $\Gamma.A$ world, it can have $x_1, \cdots, x_{n+1}$ as symbol. When we meet $x_{n+1}$, then substitution it by $a$, and when we meet $x_1, \cdots, x_n$, then substitution it by following $\gamma$. 
Then since $a$ is well-formed term in $\Delta$ and it's type is $A[\gamma]$, which do roles of $A$ in $\Delta$ world, so such substitution also works well. This is very powerful intuition. 
Now, with above understanding, let's define more challenging and powerful rules for substitutions. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 1.3.11.]\hypertarget{construction 1.3.11}{}

\[
\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta \vdash a : A[\gamma]}
{\Delta \vdash \mathbf{p} \circ (\gamma.a) = \gamma : \Gamma}
\]
\\
\[
\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta \vdash a : A[\gamma]}
{\Delta \vdash \mathbf{q}[\gamma.a] = a : A[\gamma]}
\]
\\
\[
\inferrule
{\Gamma \vdash A \text{ type} \quad \Delta \vdash \gamma : \Gamma.A}
{\Delta \vdash \gamma = (\mathbf{p}\circ \gamma).\mathbf{q}[\gamma] : \Gamma.A}
\]
\\
\end{tcolorbox} 

There rules are seemed to be very unclear. However, see following diagram. For first rule, 
\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]
We can represent the first rule as following way. 

\[
\begin{tikzcd}
    \Delta \arrow[r, "\gamma", red] \arrow[rd, "\gamma.a"', blue] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left, blue]
\end{tikzcd}
\]
So we can intuitively know that $\gamma$ and $\mathbf{p} \circ (\gamma.a)$ represent same traffic way from $\Delta$ to $\Gamma$. 
For second rule, we already explained in front page. When we meet $x_{n+1}$ (i.e. meet $q$ in $\Gamma.A$) 
then bring it from $\Gamma.A$ into $\Delta$ and substitute by $a$, term of $\Delta$. This rule explicitly claim this intuition. 
For third rule, let's draw slightly changed diagram. 

\[
\begin{tikzcd}
    \Delta  \arrow[rd, "\gamma"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]

Can we see what is $(\mathbf{p} \circ \gamma)$ here? We can draw 

\[
\begin{tikzcd}
    \Delta \arrow[r, "p\circ \gamma", red] \arrow[rd, "\gamma"'] & \Gamma \arrow[d, "id.?", shift left]\\
    & \Gamma.A \arrow[u, "p", shift left]
\end{tikzcd}
\]

Now, see \ref{subst extend}. When we make $\mathbf{p} \circ \gamma : \Delta \rightarrow \Gamma$ to something that $\Delta \rightarrow \Gamma.A$, 
we append something to $\mathbf{p} \circ \gamma$. Here, actually the answer is already given. Suppose 
$q$ in $\Gamma.A$, it has type $A[\mathbf{p}]$ in $\Gamma.A$. We define $\gamma$ by, how we take variable $\mathbf{q}$ in $\Gamma.A$ to $\Delta$? 
Actually its answer is $\mathbf{q}[\gamma]$. It has type $A[\mathbf{p}][\gamma] = A[\mathbf{p} \circ \gamma]$ in $\Delta$. 
So to make same substitution with $\gamma$, we must append $\mathbf{q}[\gamma]$ at $\mathbf{p}\circ \gamma$. This intuition gives us $\gamma = (\mathbf{p}\circ \gamma).\mathbf{q}[\gamma]$ in $\Delta$. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.1]

Prove that if $\Gamma \vdash \gamma : \Gamma.A$, then $\mathbf{p} \circ \gamma = \textbf{id}$
\begin{proof}
    How can we define $\gamma$? The intuitive meaning of $\gamma$ is that, way to bring types and terms 
    of $\Gamma.A$ into $\Gamma$. Imagine that $\Gamma.A$ contains types of $x_1, \cdots, x_{n+1}$ and 
    $\Gamma$ contains types of $x_1, \cdots, x_n$. To bring types and terms in $\Gamma.A$ into $\Gamma$, only to do is when we meet $x_{n+1}$, substitute it with well-formed term in $\Gamma$ context. 
    By this way we can delete the appearance of $x_{n+1}$ and make types and terms in $\Gamma.A$ become types and terms in $\Gamma$. 
    So, $\gamma$ is defined by following way. This is construction \hyperlink{subst extend}{1.3.10.}
    \[
    \inferrule
    {\Gamma \vdash \textbf{id} : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma \vdash a : A}
    {\Gamma \vdash \underbrace{\textbf{id}.a}_{\gamma} : \Gamma.A}
    \]
    However, according to \hyperlink{construction 1.3.11}{construction 1.3.11} we can know that 
    \[\mathbf{p} \circ (\mathbf{id}.a) = \mathbf{id}\]
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.2]
Show that $(\gamma.a) \circ \delta = (\gamma \circ \delta).a[\delta]$

\begin{proof}
    Recall third rule in \hyperlink{construction 1.3.11}{construction 1.3.11.}, 
    \[
    \inferrule
    {\Gamma \vdash A \text{ type} \quad \Delta \vdash \gamma^* : \Gamma.A}
    {\Delta \vdash \gamma^* = (\mathbf{p}\circ \gamma^*).\mathbf{q}[\gamma^*] : \Gamma.A}
    \]
    Here, the pre-suppostions of problem is that $\Delta \vdash \gamma : \Gamma$, $\Delta \vdash a : A[\gamma]$, $\Gamma \vdash A \text{ type}$ and $\delta$ be any substitution $\delta : \Lambda \rightarrow \Delta$. 
    In diagram, 
    \[
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"] & \Gamma \\
        \Lambda \arrow[u, "\delta"] & \Gamma.A
    \end{tikzcd}
    \]
    (Continue in Next Page . . .)
\end{proof}
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.2]
    For intuition, we can draw following substitution. 
    \[
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"] \arrow[rd, "\gamma.a"] & \Gamma \\
        \Lambda \arrow[u, "\delta"] \arrow[r, "(\gamma.a)\circ \delta"', red] & \Gamma.A
    \end{tikzcd}
    \]
    And also, 
    \[
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"]  & \Gamma \\
        \Lambda \arrow[u, "\delta"] \arrow[ru, "\gamma \circ \delta", blue] & \Gamma.A
    \end{tikzcd}
    \implies 
    \begin{tikzcd}
        \Delta \arrow[r, "\gamma"]  & \Gamma \\
        \Lambda \arrow[u, "\delta"] \arrow[ru, "\gamma \circ \delta", blue] \arrow[r, "(\gamma \circ \delta).?"', blue] & \Gamma.A
    \end{tikzcd}
    \]
    Here our claim is that $?$ part is $a[\delta]$ and $(\gamma.a)\circ \delta = (\gamma \circ \delta).a[\delta]$. 
    At first, let 
    \[\gamma^* = (\gamma.a) \circ \delta\]
    Then $\Lambda \vdash \gamma^* : \Gamma.A$ because 
    \[
    \inferrule
    {\Lambda \vdash \delta : \Delta \quad \Delta \vdash \gamma.a : \Gamma.A}
    {\Lambda \vdash \underbrace{(\gamma.a) \circ \delta}_{\gamma^*} : \Gamma.A}
    \]
    So we can apply \hyperlink{construction 1.3.11}{construction 1.3.11.}
    \[
    \inferrule
    {\Gamma \vdash A \text{ type} \quad \Lambda \vdash (\gamma.a) \circ \delta : \Gamma.A}
    {\Lambda \vdash (\gamma.a) \circ \delta = \underbrace{(\mathbf{p} \circ ((\gamma.a) \circ \delta)).\mathbf{q}[(\gamma.a)\circ \delta]}_{(*)} : \Gamma.A}
    \]
    Here, our claim is that $(*) = (\gamma \circ \delta).a[\delta]$. This is because, 
    \begin{align*}
        & (\mathbf{p} \circ ((\gamma.a) \circ \delta)).\mathbf{q}[(\gamma.a)\circ \delta] \\
        & = ((\mathbf{p} \circ (\gamma.a)) \circ \delta).\mathbf{q}[(\gamma.a)\circ \delta] \\
        & = (\gamma \circ \delta).\mathbf{q}[(\gamma.a)\circ \delta] \\
        & = (\gamma \circ \delta).(\mathbf{q}[\gamma.a][\delta]) \\
        & = (\gamma \circ \delta).a[\delta]
    \end{align*}
    This is end of proof. 
\end{tcolorbox}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.3]\hypertarget{gamma.A}{}
    Given $\Delta \vdash \gamma : \Gamma$ and $\Gamma \vdash A \text{ type}$, construct $\gamma.A$ such that 
    $\Delta.A[\gamma] \vdash \gamma.A : \Gamma.A$. 
    \begin{proof}
        Actually, this is also very clear notion. Let's see following diagram. 
        \[
        \begin{tikzcd}
            \Delta \arrow[r, "\gamma"] & \Gamma \\
            \Delta.A[\gamma] \arrow[u, "p_\Delta"] & \Gamma.A
        \end{tikzcd}
        \]
        This implies that 
        \[
        \begin{tikzcd}
            \Delta \arrow[r, "\gamma"] & \Gamma \\
            \Delta.A[\gamma] \arrow[u, "p_\Delta"] \arrow[ru, "\gamma \circ p_\Delta", red] & \Gamma.A
        \end{tikzcd}
        \]
        And our intuition for $\gamma.A$ is that 
        \[
        \begin{tikzcd}
            \Delta \arrow[r, "\gamma"] & \Gamma \\
            \Delta.A[\gamma] \arrow[r, "\gamma.A", "(\gamma \circ p_\Delta).?"', blue] \arrow[u, "p_\Delta"] \arrow[ru, "\gamma \circ p_\Delta", red] & \Gamma.A
        \end{tikzcd}
        \]
        We can apply \hyperlink{subst extend}{substitution extend rule} here. 
        \[
        \inferrule
        {\Delta.A[\gamma] \vdash \gamma \circ \mathbf{p}_\Delta : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Delta.A[\gamma] \vdash \mathbf{q} : A[\gamma][\mathbf{p}_\Delta] = A[\gamma \circ \mathbf{p}_\Delta]}
        {\Delta.A[\gamma] \vdash (\gamma \circ \mathbf{p}_\Delta).\mathbf{q} : \Gamma.A}
        \]
        Actually, this is our construction for $\gamma.A$. 
        \[\gamma.A := (\gamma \circ \mathbf{p}).\mathbf{q}, \quad \gamma.A : \Delta.A[\gamma] \rightarrow \Gamma.A\]
    \end{proof}
\end{tcolorbox}

\newpage 

\chapter{Internalizing Judgemental Structure : $\Pi, \Sigma, \text{Eq}, \text{Unit}$}

\section{Basic Intuitions}\hypertarget{intuition-2.1.}{}

We noted that Dependent Type Theory is similar with First Order Logic. In first order logic, 
there exists notion of assignment $s$ in Interpretation $\mathfrak{A} = \left<|\mathfrak{A}|, I\right>$ and 
variants of assignments. Both are corresponds into context $\Gamma$ and substitution $\gamma$ in chapter 1. 
And then, what's the remaining things? Since dependent type is similar with FOL formulas, 
we need to construct intuition of correspondings between them. First, FOL terms are corresponds with \lq terms' in our system. 
Second, predicates are corresponds with \lq type(dependent type)' in our system. These are all what we talk about in previous chapter. 
Remain things are connectives, quantifiers, true and false. (And one specific predicate, equality judgement.) 
They are corresponds w.r.t. non-dependent connectives, dependent sum($\exists$), dependent product($\forall$), Unit and Void. 
\\

I'll try to make more clear between those similarity, in each section. Before that, let's claim the slogan for (any) these 
connective or quantifier constructors. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=red!75!black,title=Slogan]\hypertarget{slogan}{}

Any such connectives or quantifiers in our system is given by claiming followings : 

\begin{enumerate}
    \item Natural Type-forming Operation
    \item Natural Isomorphism Relating that Type's terms to judgementally-determined structure. 
\end{enumerate}

\end{tcolorbox}

First one means that for each newly introduced types in this chapter, there are 
explicit and meta-level clear construct operation for such type. i.e. We must have the recipe of type. \\
Second one means that, if we collect all terms that have types that introduced here, then the set must have 
isomorphism (meta-level meaning) with external (meta-level) structure. 

\section{Dependent Sums}

First of all, let's make clear all the \hyperlink{intuition-2.1.}{intuitions} for dependent sum. 
\begin{enumerate}
    \item The type former of dependent sum is $\Sigma$. We'll define soon. 
    \item Dependent sum's judgementally-determined structure is \lq dependent pair'. 
    \item Dependent sum is similar to $\exists$. 
\end{enumerate}

What is dependent pair? Imagine following \lq type' in dependent type system. 
\[(n : Nat,\text{  } \text{Vec } A\text{ }n)\]
Actually, this is not matched with our construction of De Bruijn index. Matched version is that 
\[(Nat, \text{  } \text{Vec } A\text{ }\mathbf{q})\]
Then imagin the Curry-Howard corresponds here. The term of above type is like \lq one' specific example of above pair, for example
\[(2, [a, a'])\]
We can understand that this is proof for 
\[(\exists n : Nat)(\text{Vec }A\text{ n})\]
In this intuition, we say that dependent sum is similar to $\exists$. From now on, 
let's construct above intuitions explicitly by defining operations, isomorphisms, and rules. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.1. Natural Type Formal]
\[\Sigma_{\Gamma} : \left(\biguplus_{A \in Ty(\Gamma)}Ty(\Gamma.A)\right) \rightarrow Ty(\Gamma)\]
\end{tcolorbox}

The domain space's meaning is (1) choose valid type $A$ in $\Gamma$ context and (2) Under previous choose, choose valid type in $\Gamma.A$. 
Then the codomain space's meaning is that, by this $\Sigma_{\Gamma}$ operator, such pair become valid type in $\Gamma$. Then 
where is \lq Natural' ? It's intuitive meaning is that, we can feel free to choose context $\Gamma$ here. i.e. freely substitute and then change context, the 
operator's working does not changed. We can write above natural mapping as following inference rules. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.1. Natural Type Formal ( inference rule ver. )]
\begin{mathpar}
\inferrule
{\Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}}
{\Gamma \vdash \Sigma(A, B) \text{ type}}
\and   
\inferrule
{\Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}}
{\Delta \vdash \Sigma(A,B)[\gamma] = \Sigma(A[\gamma], B[\gamma.A]) \text{ type}}
\end{mathpar}    
\end{tcolorbox}

For the second rule, it can be not clear that why $B[\gamma.A]$ introduced. Let's draw the diagram. 
See \hyperlink{gamma.A}{this construction for $\gamma.A$}
\[
\begin{tikzcd}[column sep=huge, row sep=large]
    \Delta \arrow[r, "\gamma"] & \Gamma   \\
    \Delta.A[\gamma] \arrow[r, "\gamma.A"', red] & \Gamma.A
\end{tikzcd}
\]

We can pull-back $A$ form $\Gamma$ to $\Delta$ through $\gamma$. And note that $B$ is type in the $\Gamma.A$. So if we pulling back this into $\Delta.A[\gamma]$, 
using $\gamma.A$. So, the pull-backed type is $B[\gamma.A]$ in $\Delta.A[\gamma]$. It means that 
\[\Delta \vdash A[\gamma] \text{ type}, \quad \Delta.A[\gamma] \vdash B[\gamma.A] \text{ type}\]
Then the type-formal implies that 
\[\Delta \vdash \Sigma(A[\gamma], B[\gamma.A]) \text{ type}\]
And naturality means that, this type works same with $\Sigma(A, B)$ in $\Gamma$. So construct identity with 
it's pull-backed version $\Sigma(A, B)[\gamma]$ and above. 
\\

Then here, how can we define the isomorphism between \lq terms' that have $\Sigma(A,B)$ types and such meta-level notion of \lq pair'? See 

\[\iota_{\Gamma, A, B} : \text{Tm}(\Gamma, \Sigma(A,B)) \xrightarrow{\cong} \biguplus_{a \in \text{Tm}(\Gamma, A)}\text{Tm}(\Gamma, B[\mathbf{id}.a])\]
\\
Note that this is isomorphism on the \lq terms'. Right-hand side contain all dependent pairs (meta-level representation) and 
our goal is match our new type $\Sigma$ into that notion. This setting is just done at abstraction level. Now 
our interests are (1) How can we unfold above isomorphism explicitly, using inference rules? 
(2) Can we define $\iota_{\Gamma, A, B}, \iota_{\Gamma, A, B}^{-1}$ and round-trip among them 
preserves structures? (3) Do such constructions have naturality? \\

These are remain works in this chapter. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.16.]
Construct non-dependent pair type, with dependent sum $\Sigma$. 

\begin{proof}
    TODO
\end{proof}

\end{tcolorbox}

Now let's construct above isomorphisms explicitly. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.2.]
This is explicit un-packing of $\iota_{\Gamma, A, B}$ 
\[
\inferrule
{ \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)}
{ \Gamma \vdash \mathbf{fst}(p) : A}
\]
\[
\inferrule
{ \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)}
{ \Gamma \vdash \mathbf{snd}(p) : B[\mathbf{id.fst}(p)]}
\]
\end{tcolorbox}

Second construction is very genious. It gives us very good intuition. When $\Gamma \vdash p : \Sigma(A, B)$ is given, 
we can take first element $a$ of $p$ easily. And then, when we meet $\mathbf{q}$ in type $B$, 
automatically understand that it is $a$ we taken. By this we can write 
\[(2, [a_1, a_2]) : \Sigma(Nat, \mathbf{Vec} \text{ A }\mathbf{q})\]
Actually above type generally represents following intuitive type without variable names. 
\[(n\text{ : Nat}, \mathbf{Vec }\text{ A }\mathbf{n})\] 
\\
Then now, it's time to clarify the inverse isomorphism $\iota_{\Gamma, A, B}^{-1}$. Intuitive meaning of this isomorphism is that, 
connect each meta-level dependent pair terms into our type system. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.3.]

\[\iota_{\Gamma, A, B}^{-1} : \uplus_{a \in \text{Tm}(\Gamma, A)} \text{Tm}(\Gamma, B[\textbf{id}.a]) \longrightarrow \text{Tm}(\Gamma, \Sigma(A, B))\]

\[
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Gamma \vdash \textbf{pair}(a, b) : \Sigma(A, B)
}
\]

\end{tcolorbox}
I want to write some understanding for this construction. I think that most important one is 
that $b$ is absolutely term of $\Gamma$. So, we can't use exact term $a$ via $\mathbf{q}$ when express $b$. 
However, term $a$ is used when express type of $b$, without writing $a$ directly. This is very very similar with 
$\exists$ quantifier. Imagine that we have set of premises $\Gamma$. Let's interpret above inference rule. 
\begin{enumerate}
    \item Under premises $\Gamma$, we have proof of $A$ via $a$. 
    \item Under premises $\Gamma$ with $A$, claim $B$. 
    \item Under premises $\Gamma$, $b$ is proof of $B[\mathbf{id}.a]$. 
\end{enumerate}
These three Curry-Howard statements give us intuition about the result of inference rule. 
\begin{enumerate}
    \item There exists proof $a$ of $A$. By using this, we can prove $B[\textbf{id}.a]$ via $b$. 
    \item $\iff$ $(\exists x).(B[\textbf{id}.x])$ satisfiable. 
\end{enumerate}
Now second job is that claiming these two isomorphisms are symmetric. It means that 
the correspondings between our type system and meta-level dependent pair is bijective. Actually 
proving is done by constructing $\beta$-rule and $\eta$-rule. To show bijective, we just show that round-trip between 
terms and meta-pairs always preserve original element. Formally, we want to make 
\[\iota_{\Gamma, A, B} \circ \iota_{\Gamma, A, B}^{-1} = \textbf{id}_{\textbf{meta}}, \quad \iota_{\Gamma, A, B}^{-1} \circ \iota_{\Gamma, A, B} = \textbf{id}_{\textbf{term}}\]
\\
This is guaranteed explicitly via following rules. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.4.]
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash p : \Sigma(A, B)
}
{
    \Gamma \vdash \textbf{pair}(\textbf{fst}(p), \textbf{snd}(p)) = p : \Sigma(A, B)
}
\qquad \text{($\beta$-rule)}
\]
\begin{mathpar}
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Gamma \vdash \textbf{fst}(\textbf{pair}(a, b)) = a : A
}
\qquad \text{($\eta$-rule)}
\and   
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Gamma \vdash \textbf{snd}(\textbf{pair}(a, b)) = b : B[\textbf{id}.a]
}
\qquad \text{($\eta$-rule)}
\end{mathpar}
\end{tcolorbox}
Recap our ultimate goal. The last job is clarify that this isomorphism has naturality. \lq Naturality' means that 
we can freely use substitutions when apply this rule, or more easily, for all contexts, these pair structure is preserved. 
For this sake, we can make formal construction by rule also. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.2.5.]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash b : B[\textbf{id}.a]
}
{
    \Delta \vdash \textbf{pair}(a, b)[\gamma] = \textbf{pair}(a[\gamma], b[\gamma]) : \Sigma(A, B)[\gamma]
}
\]
\end{tcolorbox}
This is very intuitive. When we make $\textbf{pair}(a, b)$ toy in $\Gamma$, we have 2 ways to take that toy into $\Delta$ via $\gamma$. 
First way is that take the toy directly ($\textbf{pair}(a,b)[\gamma]$) and second way is that 
take two materials ($a[\gamma], b[\gamma]$) and make in $\Delta$ (then, $\textbf{pair}(a[\gamma], b[\gamma])$). This rule say that 
both are same. This is intuitive meaning of naturality. However, this is just naturality of $\iota_{\Gamma, A, B}^{-1}$. 
We need to show naturality of $\iota_{\Gamma, A, B}$ also. But this is derivable. 
\begin{align*}
    \textbf{fst}(p[\gamma]) &= \textbf{fst}(\textbf{pair}(\textbf{fst}(p), \textbf{snd}(p))[\gamma]) \\
    &= \textbf{fst}(\textbf{pair}(\textbf{fst}(p)[\gamma], \textbf{snd}(p)[\gamma])) \\
    &= \textbf{fst}(p)[\gamma]
\end{align*}

\begin{tcolorbox}[colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.17.]
Show that well-typedness of $b[\gamma]$ in Construction 2.2.5. 

\begin{proof}
    Our goal is showing that $\Delta \vdash b[\gamma] : B[\gamma.A][\textbf{id}.a[\gamma]]$(And this is well-formed type in $\Delta$ also). This is from 
    pattern-matching with Construction 2.2.3. 
    See following diagram first. 
    \[
    \begin{tikzcd}[column sep=huge]
        \Delta \arrow[r, "\gamma", blue] \arrow[d, "{id.a[\gamma]}"', red] \arrow[rd, "{\gamma.a[\gamma]}", purple] & \Gamma \arrow[d, "id.a"] \\
        \Delta.A[\gamma] \arrow[r, "\gamma.A", red] & \Gamma.A
    \end{tikzcd}
    \]
    Then see how can we take $B$ from $\Gamma.A$ to $\Delta$ and $b$ from $\Gamma$ to $\Delta$. 
    $B$ is pull-backed through red way and $b$ is pull-backed through blue way. So 
    $b[\gamma]$ is well-formed term in $\Delta$. And similary, $B[\gamma.A][\textbf{id}.a[\gamma]]$ is well-formed type in $\Delta$. 
    Last, we must show that $b[\gamma]$ has such type. Since we know that $\Gamma \vdash b : B[\textbf{id}.a]$, 
    it is clear that $\Delta \vdash b[\gamma] : B[\textbf{id}.a][\gamma]$. Then we can complete proof via showing 
    $\Delta \vdash B[\gamma.A][\textbf{id}.a[\gamma]] = B[\textbf{id}.a][\gamma] \text{ type}$. This holds because 
    \begin{align*}
        [\gamma.A][\textbf{id}.a[\gamma]] &= \gamma.A \circ (\textbf{id}.a[\gamma]) \\
        &= \gamma.a[\gamma] \qquad \text{$\because$ purple arrow above} \\
        &= (\textbf{id}.a) \circ \gamma \\
        &= [\textbf{id}.a][\gamma]
    \end{align*}
\end{proof}
\end{tcolorbox}

\newpage 

\section{Dependent Products}

Here also, follow up the constructing of previous chapter. We'll clarify intuition for this type by : 
\begin{enumerate}
    \item The type former of dependent product is $\Pi$. We'll define soon. 
    \item Dependent product's judgementrally-determined structure is \lq dependent function'. 
    \item Dependent product is similar to $\forall$. 
\end{enumerate}

Here, what is dependent function? Imagin following type in dependent type system. 
\[(n : Nat) \longrightarrow \textbf{Vec}\text{ }A \text{ }n\]
The term of above type works like a function, whose input is natural number $n$ and output is 
vector with length $n$. So this is very similar with $\forall$. Once we throw any natural number $n$, it returns 
proof of output type. i.e. this type is similar to claim that
\[(\forall n : Nat)(\textbf{Vec}\text{ }A\text{ }n)\]
\\
Recap the \hyperlink{slogan}{slogan}. When we introduce types here, we'll define (1) Natural Type Former and (2) Natural Isomorphisms between terms and external structure. 
As we've studied in previous chapter, we can expect what are them. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.1. Natural Type Formal]
\[\Pi_{\Gamma} : \left(\biguplus_{A \in Ty(\Gamma)} Ty(\Gamma.A)\right) \rightarrow Ty(\Gamma)\]
\end{tcolorbox}
And then, we can construct explicit rules for make this operator as same previous. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.2.]

\begin{mathpar}
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}
}
{
    \Gamma \vdash \Pi(A, B)\text{ type}
}
\and   
\inferrule 
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}
}
{
    \Delta \vdash \Pi(A, B)[\gamma] = \Pi(A[\gamma], B[\gamma.A]) \text{ type}
}
\end{mathpar}

\end{tcolorbox}

This is our \lq type former' for dependent product. Actually for understanding type forming, 
it isn't difficult since we deal samely in previous chapter. Now our goal is that, find and define 
natural isomorphisms between \lq terms' that have $\Pi(A, B)$ type and meta-level notion of \lq dependent function'. 
Imagine that following two sets are isomorphic. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.3. Natural Isomorphism of Terms]

\[Tm(\Gamma, \Pi(A, B)) \quad \cong \quad Tm(\Gamma.A, B)\]
And divide each isomorphism via 
\[\iota_{\Gamma, A \rightarrow B} : Tm(\Gamma, \Pi(A, B)) \xrightarrow{\cong} Tm(\Gamma.A, B)\]
\[\iota_{\Gamma, A \rightarrow B}^{-1} : Tm(\Gamma.A, B) \xrightarrow{\cong} Tm(\Gamma, \Pi(A, B))\]

\end{tcolorbox}

Now, let's do same construction with previous chapter. (1) How can we unfold above isomorphism explicitly, using inference rules? 
(2) Can we define $\iota_{\Gamma, A\rightarrow B}, \iota_{\Gamma, A\rightarrow B}^{-1}$ and 
round-trip among them presereves structures? (3) Do such constructions have naturality? 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.4.]
Let's unpack $\iota_{\Gamma, A\rightarrow B}$
\begin{mathpar}
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B)
}
{
    \Gamma \vdash \textbf{app}(f, a) : B[\textbf{id}.a]
}
\end{mathpar}
Let's unpack $\iota_{\Gamma, A\rightarrow B}^{-1}$
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash b : B
}
{
    \Gamma \vdash \lambda(b) : \Pi(A, B)
}
\]

\end{tcolorbox}

Both are very intuitive. First one is application of function, and second one is lambda-definition of function without variable name. 
However, I want to note some slight difference between dependent sum and above. 
One difference is that, place that $b$ exists. At dependent sum, $b$ exists in $\Gamma$ context. 
So we explain that we can't use $\mathbf{q}$ for express $a$ in $b$. However, at above, $b$ is term of $\Gamma.A$ world. So 
we can use $\mathbf{q}$ for represent $b$. This is one of major difference. Further, by this, we can 
agree our abstractical notion for matching of $\forall$ and $\Pi$. We can always take proof $b$ of $B$ under premises $\Gamma$ appended with $A$ by substitution $\textbf{id}.a$ for all $a$. 
It gives us that, with any proof $x$ of $A$, $B[\textbf{id}.x]$ is true. Formally, existance term of type $\Pi(A, B)$ is proof of
\[(\forall x).(B[\textbf{id}.x])\]

The next job is that claiming these two isomorphisms are symmetric. Similar to previous chapter, we need to define 
\[\iota_{\Gamma, A\rightarrow B}\circ \iota_{\Gamma, A\rightarrow B}^{-1} = \textbf{id}_{meta}, \quad \iota_{\Gamma, A\rightarrow B}^{-1} \circ \iota_{\Gamma, A\rightarrow B} = \textbf{id}_{term}\]
\\
This is guaranteed explicitly via following rules. 
\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.5.]
\[
\inferrule
{
    \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B)
}
{
    \Gamma \vdash \lambda(\textbf{app}(f[\mathbf{p}], \mathbf{q})) = f : \Pi(A, B)
}
\qquad \text{($\beta$-rule)}
\]
\[
\inferrule
{
    \Gamma \vdash a : A \quad \Gamma.A \vdash b : B
}
{
    \Gamma \vdash \textbf{app}(\lambda(b), a) = b[\textbf{id}.a] : B[\textbf{id}.a]
}
\qquad \text{($\eta$-rule)}
\]
\end{tcolorbox}

Our final goal is state that this isomorphism has naturality. This can be holded by make following rules explicitly. 

\begin{tcolorbox}[colback=yellow!10!white,colframe=green!75!black,title=Construction 2.3.6.]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash B \text{ type}
}
{
    \Delta \vdash \Pi(A, B)[\gamma] = \Pi(A[\gamma], B[\gamma.A]) \text{ type}
}
\]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash A \text{ type} \quad \Gamma.A \vdash b : B
}
{
    \Delta \vdash \lambda(b)[\gamma] = \lambda(b[\gamma.A]) : \Pi(A, B)[\gamma]
}
\]
\[
\inferrule
{
    \Delta \vdash \gamma : \Gamma \quad \Gamma \vdash a : A \quad \Gamma.A \vdash B \text{ type} \quad \Gamma \vdash f : \Pi(A, B) 
}
{
    \Delta \vdash \textbf{app}(f, a)[\gamma] = \textbf{app}(f[\gamma], a[\gamma]) : B[\gamma.a[\gamma]]
}
\]
\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.6.]
At Construction 2.3.6. prove that $\textbf{app}(f, a)[\gamma]$ and $\textbf{app}(f[\gamma], a[\gamma])$ have the type $B[\gamma.a[\gamma]]$. 

\begin{proof}
    Let's drow diagram, 
    \[
    \begin{tikzcd}[column sep = huge]
        \Delta \arrow[r, "\gamma"] \arrow[rd, "{\gamma.a[\gamma]}"] \arrow[d, "{id.a[\gamma]}"'] & \Gamma \arrow[d, "id.a"] \\
        \Delta.A[\gamma] \arrow[r, "\gamma.A"] & \Gamma.A
    \end{tikzcd}
    \]
    We can take $a$ form $\Gamma$ to $\Delta$, type $B$ from $\Gamma.A$ to $\Delta.A[\gamma]$, and take $f$ from $\Gamma$ to $\Delta$. It gives us 
    \[\Delta \vdash a[\gamma] : A[\gamma] \quad \Delta.A[\gamma] \vdash B[\gamma.A] \text{ type} \quad \Delta \vdash f[\gamma] : \Pi(A, B)[\gamma]\]
    Then by Construction 2.3.4. we can get 
    \[\Delta \vdash \textbf{app}(f[\gamma], a[\gamma]) : B[\gamma.A][\textbf{id}.a]\]
    However, we know that $B[\gamma.A][\textbf{id}.a] = B[\gamma.a[\gamma]]$, so 
    \[\Delta \vdash \textbf{app}(f[\gamma], a[\gamma]) : B[\gamma.a[\gamma]]\]
    And first one is easier, we can take $\textbf{app}(f, a) : B[\textbf{id}.a]$ from $\Gamma$ into $\Delta$. 
    \[\Delta \vdash \textbf{app}(f, a)[\gamma] : B[\textbf{id}.a][\gamma] = B[(\textbf{id}\circ \gamma).a[\gamma]] = B[\gamma.a[\gamma]]\]
\end{proof}

\end{tcolorbox}

\begin{tcolorbox}[breakable, colback=yellow!10!white,colframe=brown!75!black,title=Exercise 2.7.]
At Construction 2.3.5. prove that $\lambda(\textbf{app}(f[\mathbf{p}], \mathbf{q}))$ is well-formed term of $\Pi(A, B)$ in $\Gamma$. 
\begin{proof}
    Our goal is showing 
    \[\Gamma \vdash \lambda(\textbf{app}(f[\textbf{p}], \textbf{q})) : \Pi(A, B)\]
    To this is valid, we need 2 premises 
    \[\Gamma \vdash A \text{ type}, \qquad \Gamma.A \vdash \textbf{app}(f[\textbf{p}], \textbf{q}) : B\]
    First one is premised, so let's prove second one. Since $f$ is term of $\Gamma$, so take it to $\Gamma.A$ then $f[\textbf{p}]$. So, 
    we know that 
    \[\Gamma.A \vdash f[\textbf{p}] : \Pi(A, B)[\textbf{p}], \quad \Gamma.A \vdash \textbf{q} : A[\textbf{p}], \qquad \Gamma.A.A[\textbf{p}] \vdash B[\textbf{p}.A] \text{ type}\]
    Then with Construction 2.3.4. we can get 
    \[\Gamma.A \vdash \textbf{app}(f[\textbf{p}], \textbf{q}) : B[\textbf{p}.A][\textbf{id.q}]\]
    Then remain thing to show is 
    \[\Gamma.A \vdash B = B[\textbf{p}.A][\textbf{id.q}] \text{ type}\]
    Actually, this is intuitive. $\textbf{p}.A$ is weakening from $\Gamma.A$ into $\Gamma.A.A[\textbf{p}]$. So it is just 
    send $B$ in $\Gamma.A$ to $\Gamma.A.A[\textbf{p}]$ and take it again through $\textbf{id.q}$. Formal writing is that, 
    \[B[\textbf{p}.A][\textbf{id.q}] = B[\textbf{p}.A \circ \textbf{id.q}] = B[(\textbf{p}\circ \textbf{id}).\textbf{q}] = B[\textbf{p.q}] = B\]
    This is end of proof. 
\end{proof}
\end{tcolorbox}

\newpage  
.
\end{document}